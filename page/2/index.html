<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.1.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.2">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.2" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="keywords" content="魏远标,Sherwin,java程序员,程序员Sherwin,程序员魏远标">
<meta property="og:type" content="website">
<meta property="og:title" content="程序员Sherwin">
<meta property="og:url" content="http://weiyuanbiao.cn/page/2/index.html">
<meta property="og:site_name" content="程序员Sherwin">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="程序员Sherwin">





  
  
  <link rel="canonical" href="http://weiyuanbiao.cn/page/2/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>程序员Sherwin</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">程序员Sherwin</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">程序员Sherwin</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-读书">

    
    
    
      
    

    

    <a href="/books" rel="section"><i class="menu-item-icon fa fa-fw fa-book"></i> <br>读书</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-电影">

    
    
    
      
    

    

    <a href="/movies" rel="section"><i class="menu-item-icon fa fa-fw fa-film"></i> <br>电影</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://weiyuanbiao.cn/网络/http三次握手和四次挥手/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sherwin Wei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序员Sherwin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/网络/http三次握手和四次挥手/" class="post-title-link" itemprop="url">tcp三次握手四次挥手</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-06-12 00:16:29" itemprop="dateCreated datePublished" datetime="2018-06-12T00:16:29+08:00">2018-06-12</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-01-23 17:11:07" itemprop="dateModified" datetime="2019-01-23T17:11:07+08:00">2019-01-23</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/网络/" itemprop="url" rel="index"><span itemprop="name">网络</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="tcp三次握手四次挥手"><a href="#tcp三次握手四次挥手" class="headerlink" title="tcp三次握手四次挥手"></a>tcp三次握手四次挥手</h2><h3 id="三次握手："><a href="#三次握手：" class="headerlink" title="三次握手："></a>三次握手：</h3><ul>
<li>第一次：客户端给服务器发请求说，我要和你建立连接        SYN=1</li>
<li>第二次：服务器给客户端说，我知道了，那咱两建立连接把     ACK=1  SYN=1</li>
<li>第三次：客户端对服务器说，好的，我知道你知道  我要和你建立连接了   ACK=1</li>
</ul>
<h4 id="为什么不是两次握手呢？"><a href="#为什么不是两次握手呢？" class="headerlink" title="为什么不是两次握手呢？"></a>为什么不是两次握手呢？</h4><ul>
<li>第一次：客户端给服务器发请求说，我要和你建立连接</li>
<li>第二次：服务器给客户端说，我知道了，那咱两建立连接把</li>
</ul>
<p>&emsp;&emsp;客户端给服务发消息，服务器由于网络阻塞或者别的原因没有收到，就不会回应，客户端一段时间没有收到服务器给他回的消息，他就会重新发送一个请求，现在在他重新发送请求后，服务器且回应了，建立连接后，且服务器收到前段时间的失效报文，服务器就建立了连接，准备接受数据。但是他已经失效了，客户端就对那个失效的消息不感冒，就不传数据，然后服务器就一直等啊等啊等着他传数据，就浪费了服务器资源。</p>
<p>&emsp;&emsp;如果是三次握手的话，客户端再给他回一句，我知道了，我等哈就给你发数据，然后这样他两才链接上，</p>
<p>&emsp;&emsp;如果客户端没给他回消息，服务器就不会和他建立连接，就不会一直等啊等啊。</p>
<p>&emsp;&emsp; 所以避免浪费服务器资源。</p>
<h3 id="四次挥手："><a href="#四次挥手：" class="headerlink" title="四次挥手："></a>四次挥手：</h3><p>&emsp;&emsp; 链接时是个全双工的过程，一般都是浏览器给服务器说，很少服务器给浏览器说挥手的，</p>
<ul>
<li>第一次：浏览器给服务器说，我现在要断开tcp链接了啊，</li>
<li>第二次：服务器给浏览器说，知道了，那就断吧，但是这个时候服务器的资源还没有发完，他还会继续给浏览器发消息，</li>
<li>第三次：当他发完了之后，他就跟浏览器说，我现在发完了，咱两可以断开了。（客户端在之前还是接收数据的，只是他不在给服务器发东西了）</li>
<li>第四次：客户端给浏览器说，好的我知道了，那就真正的断开吧。（在第四挥手的时候，有一个等待时间，在这个等待时间里，服务器不再给给客户端发消息的话，过了这段时间，客户端就默认，服务器已经收到   客户端同意和他断开的消息了。</li>
</ul>
<h4 id="为什么是四次挥手呢？"><a href="#为什么是四次挥手呢？" class="headerlink" title="为什么是四次挥手呢？"></a>为什么是四次挥手呢？</h4><p>&emsp;&emsp;关闭连接的时候，当接收到FIN通知时，只是说他没啥给你发的了，你不一定没东西给他发啊，你再次给他发FIN时，代表你没东西给他发了，双方都没东西发了，就可以完全关闭了。</p>
<p>&emsp;&emsp;就比如说，我要和你分手了，但是你对我还有感情，当你没感情的时候，也就是咱两都没感情的时候，就可以分手了，不能说我没感情就分手，不公平啊！！</p>
<h4 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h4><ul>
<li>四次挥手真实情况:</li>
<li>第一次，浏览器发送FIN</li>
<li>第二次，服务器发送ACK</li>
<li>第三次，服务器发送FIN,</li>
<li>第四次，浏览器发送ACK</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://weiyuanbiao.cn/java/spring/spring bean的生命周期/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sherwin Wei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序员Sherwin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/java/spring/spring bean的生命周期/" class="post-title-link" itemprop="url">spring bean的生命周期</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-06-11 23:02:57" itemprop="dateCreated datePublished" datetime="2018-06-11T23:02:57+08:00">2018-06-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-01-23 17:11:07" itemprop="dateModified" datetime="2019-01-23T17:11:07+08:00">2019-01-23</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/spring/" itemprop="url" rel="index"><span itemprop="name">spring</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="spring-bean的生命周期"><a href="#spring-bean的生命周期" class="headerlink" title="spring bean的生命周期"></a>spring bean的生命周期</h2><h3 id="Spring上下文的生命周期"><a href="#Spring上下文的生命周期" class="headerlink" title="Spring上下文的生命周期"></a>Spring上下文的生命周期</h3><ol>
<li><p>实例化一个Bean，也就是我们通常说的new</p>
</li>
<li><p>按照Spring上下文对实例化的Bean进行配置，也就是IOC注入</p>
</li>
<li><p>如果这个Bean实现了BeanNameAware接口，会调用它实现的setBeanName(String beanId)方法，此处传递的是Spring配置文件中Bean的ID</p>
</li>
<li><p>如果这个Bean实现了BeanFactoryAware接口，会调用它实现的setBeanFactory()，传递的是Spring工厂本身（可以用这个方法获取到其他Bean）</p>
</li>
<li><p>如果这个Bean实现了ApplicationContextAware接口，会调用setApplicationContext(ApplicationContext)方法，传入Spring上下文，该方式同样可以实现步骤4，但比4更好，以为ApplicationContext是BeanFactory的子接口，有更多的实现方法</p>
</li>
<li><p>如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessBeforeInitialization(Object obj, String s)方法，BeanPostProcessor经常被用作是Bean内容的更改，并且由于这个是在Bean初始化结束时调用After方法，也可用于内存或缓存技术</p>
</li>
<li><p>如果这个Bean在Spring配置文件中配置了init-method属性会自动调用其配置的初始化方法</p>
</li>
<li><p>如果这个Bean关联了BeanPostProcessor接口，将会调用postAfterInitialization(Object obj, String s)方法<br> <strong> 注意：</strong>以上工作完成以后就可以用这个Bean了，那这个Bean是一个single的，所以一般情况下我们调用同一个ID的Bean会是在内容地址相同的实例</p>
</li>
<li><p>当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean接口，会调用其实现的destroy方法</p>
</li>
<li><p>最后，如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的销毁方法</p>
</li>
</ol>
<p>以上10步骤可以作为面试或者笔试的模板，另外我们这里描述的是应用Spring上下文Bean的生命周期，如果应用Spring的工厂也就是BeanFactory的话去掉第5步就Ok了</p>
<hr>
<p>&emsp;&emsp;  Spring框架中，一旦把一个Bean纳入Spring IOC容器之中，这个Bean的生命周期就会交由容器进行管理，一般担当管理角色的是BeanFactory或者ApplicationContext,认识一下Bean的生命周期活动，对更好的利用它有很大的帮助：</p>
<p>下面以BeanFactory为例，说明一个Bean的生命周期活动</p>
<ul>
<li>Bean的建立， 由BeanFactory读取Bean定义文件，并生成各个实例</li>
<li>Setter注入，执行Bean的属性依赖注入</li>
<li>BeanNameAware的setBeanName(), 如果实现该接口，则执行其setBeanName方法</li>
<li>BeanFactoryAware的setBeanFactory()，如果实现该接口，则执行其setBeanFactory方法</li>
<li>BeanPostProcessor的processBeforeInitialization()，如果有关联的processor，则在Bean初始化之前都会执行这个实例的processBeforeInitialization()方法</li>
<li>InitializingBean的afterPropertiesSet()，如果实现了该接口，则执行其afterPropertiesSet()方法</li>
<li>Bean定义文件中定义init-method</li>
<li>BeanPostProcessors的processAfterInitialization()，如果有关联的processor，则在Bean初始化之前都会执行这个实例的processAfterInitialization()方法</li>
<li>DisposableBean的destroy()，在容器关闭时，如果Bean类实现了该接口，则执行它的destroy()方法</li>
<li>Bean定义文件中定义destroy-method，在容器关闭时，可以在Bean定义文件中使用“destory-method”定义的方法</li>
<li>如果使用ApplicationContext来维护一个Bean的生命周期，则基本上与上边的流程相同，只不过在执行BeanNameAware的setBeanName()后，若有Bean类实现了org.springframework.context.ApplicationContextAware接口，则执行其setApplicationContext()方法，然后再进行BeanPostProcessors的processBeforeInitialization()</li>
</ul>
<p>&emsp;&emsp;实际上，ApplicationContext除了向BeanFactory那样维护容器外，还提供了更加丰富的框架功能，如Bean的消息，事件处理机制等</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://weiyuanbiao.cn/生活/你连清晨都控制不了，何谈人生？/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sherwin Wei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序员Sherwin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/生活/你连清晨都控制不了，何谈人生？/" class="post-title-link" itemprop="url">你连清晨都控制不了，何谈人生？</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-06-11 09:01:27" itemprop="dateCreated datePublished" datetime="2018-06-11T09:01:27+08:00">2018-06-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-01-23 17:11:07" itemprop="dateModified" datetime="2019-01-23T17:11:07+08:00">2019-01-23</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/生活/" itemprop="url" rel="index"><span itemprop="name">生活</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="你连清晨都控制不了，何谈人生？"><a href="#你连清晨都控制不了，何谈人生？" class="headerlink" title="你连清晨都控制不了，何谈人生？"></a>你连清晨都控制不了，何谈人生？</h1><p>一日之计，始于清晨。南怀瑾先生曾说过：“能控制早晨的人，方可控制人生。”人生的改变，也许就是伴随着清晨的6点钟闹铃开始。</p>
<h2 id="以史为鉴"><a href="#以史为鉴" class="headerlink" title="以史为鉴"></a>以史为鉴</h2><p>&emsp;&emsp;自古以来，官员便要在清晨上早朝。汉代贾谊在《新书·官人》中写到：“清晨听治，罢朝而议论。”加上古时候车马不便，算上起床、梳洗、换上朝服的时间，官员们至少需要提早半个时辰，即一个小时起床。”五鼓初起，列火满门，将欲趋朝，轩盖如市。”雾色朦胧中，百官上朝。</p>
<p>&emsp;&emsp;古时没有灯，夜里读书不便，文人大多早起看书，学堂开课也早。而现在夜晚灯火通明，夜间活动丰富，不少人选择了晚睡晚起。孰不知，在你沉醉于清晨的美梦时，他人已经走在为梦想拼搏的路上了。最可怕的不是别人比你聪明，而是比你聪明的人，比你还努力。 </p>
<h2 id="名人为例"><a href="#名人为例" class="headerlink" title="名人为例"></a>名人为例</h2><p>&emsp;&emsp;高三学生学习任务重，很多学生为了能多睡十分钟，早饭能免则免。然而，这样的人并不能成为人生赢家，看看那些成功人士的作息，你会发现，提高学习效率，生活质量，从每一个清晨开始。</p>
<p>&emsp;&emsp;伊万卡·特鲁普，川普背后的关键女人，也就是他的女儿。6岁开始买股票赚钱、高中成为模特打工、先到基层锻炼后才回特朗普集团上班，之后还创立了自己的品牌，每天工作16个小时，美国大选期间，要抽出时间给川普站台演讲，下班之后还要回家抱抱孩子，经常一天只睡4小时。在晨曦中醒来，在深夜里睡去。在母亲、地产专家和时尚品牌老板这些角色中自如转换，因她不浪费每一个清晨的时光。</p>
<p>&emsp;&emsp;就算你不看NBA，不知道科比，但你肯定听过一句话：“你见过凌晨4点洛杉矶的天空吗？”科比说：“早上4点正是睡得最舒服、床铺最温暖的时候，但你需要爬起来去训练！你必须有足够的毅力，才能把你从床上拉起来去做这些事。”昨天科比在直播里说到，退役后的他依然早上4点起床。如果之前4点训练是来自成功的紧迫感，那么现在的他更多的是享受。</p>
<p>&emsp;&emsp;杰克·多西 Twitter和Square联合创始人，他每天早晨5点半准时起床，静坐后慢跑6英里。分管两家公司的人，还不能早睡，每一天都要工作满16个小时。因为事情繁多，他把时间规划精确到分钟，把众多的工作内容分配到每一天，并且高度自律严格按照计划进行。</p>
<p>&emsp;&emsp;王健林高居中国富豪前列，仍坚持这每天5点半起床，并且会在7点准时到达办公室，一直工作到晚上七八点钟。为了保持更好的体力与经历，他还坚持每天跑步一小时。</p>
<p>&emsp;&emsp;如今，李嘉诚已80多高龄，但却依然保持早起习惯，无论前一天多晚睡，第二天早晨6点一定会准时起床，随后，打一个半小时高尔夫，保证在8点前到达办公室。</p>
<p>&emsp;&emsp;研究表明，早起者通常起床更快，而且头脑更灵活，能够快速投入注意力要求较高的工作和学习中，也不容易疲劳，精力更旺盛，工作效率更高。加拿大多伦多大学的研究人员发现，任何年龄段的人，早起的情绪更加积极向上，自我感觉更好，健康意识也更加强烈。</p>
<p>&emsp;&emsp;不同行业，不同领域，成功的人都是相似的，他们懂得克制，擅长利用时间，不把有限的时间用在无谓的事上。</p>
<h2 id="时间管理"><a href="#时间管理" class="headerlink" title="时间管理"></a>时间管理</h2><p>&emsp;&emsp;说到这里，并不是让大家每天一定要起得非常早，充足的睡眠是提高效率的前提，但并不意味着可以无止境地赖在床上。因此，每一个人都应该有行程时间管理观念，合理分配时间。而这种观念最有成效的功能就是提高生活质量和学习效率。</p>
<p>&emsp;&emsp;无论哪个季节，从被窝里挣扎出来都是痛苦的。在前一天准备好第二天要穿的服装，提早半个小时起床，洗漱刷牙，做一个简单的伸展，吃一顿丰富的早餐，心情愉悦，准点打卡学习，你会发现很快便能进入状态，学习效率也有所提高。</p>
<p>&emsp;&emsp;为自己量身打造一个时间表，然后坚持固定时间早起吧。学习忙碌，也别忘了找个时间锻炼身体。一般在一天的学习后，很少人还有精力再去运动健身，不妨把运动的时间放在早上，积极参加学校组织的晨练。要知道，早上的运动可以增加血液循环，迅速唤醒身心。</p>
<p>&emsp;&emsp;一般来说，形成一个良好习惯最低需要21天，那就先给自己定一个短期计划，在21天里选择在固定的时间内早起。如果你连清晨都控制不了，又怎么控制人生。富兰克林曾说：“我未曾见过一个早起勤奋谨慎诚实的人抱怨命运不好。”</p>
<p>&emsp;&emsp;每一个不曾起舞的日子，都是对生命的辜负。改变，从清晨开始！</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://weiyuanbiao.cn/java/java 高级系列/5.LinkedHashSet的实现原理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sherwin Wei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序员Sherwin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/java/java 高级系列/5.LinkedHashSet的实现原理/" class="post-title-link" itemprop="url">5.LinkedHashSet的实现原理</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-06-07 16:14:58" itemprop="dateCreated datePublished" datetime="2018-06-07T16:14:58+08:00">2018-06-07</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-01-23 17:11:07" itemprop="dateModified" datetime="2019-01-23T17:11:07+08:00">2019-01-23</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/java高级系列/" itemprop="url" rel="index"><span itemprop="name">java高级系列</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-LinkedHashSet概述："><a href="#1-LinkedHashSet概述：" class="headerlink" title="1.    LinkedHashSet概述："></a>1.    LinkedHashSet概述：</h3><p>&emsp;&emsp; LinkedHashSet是具有可预知迭代顺序的Set接口的哈希表和链接列表实现。此实现与HashSet的不同之处在于，后者维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可为插入顺序或是访问顺序。</p>
<ul>
<li>注意，此实现不是同步的。如果多个线程同时访问链接的哈希Set，而其中至少一个线程修改了该Set，则它必须保持外部同步。</li>
</ul>
<h3 id="2-LinkedHashSet的实现："><a href="#2-LinkedHashSet的实现：" class="headerlink" title="2.    LinkedHashSet的实现："></a>2.    LinkedHashSet的实现：</h3><p>&emsp;&emsp; 对于LinkedHashSet而言，它继承与HashSet、又基于LinkedHashMap来实现的。<br>&emsp;&emsp; LinkedHashSet底层使用LinkedHashMap来保存所有元素，它继承与HashSet，其所有的方法操作上又与HashSet相同，因此LinkedHashSet 的实现上非常简单，只提供了四个构造方法，并通过传递一个标识参数，调用父类的构造器，底层构造一个LinkedHashMap来实现，在相关操作上与父类HashSet的操作相同，直接调用父类HashSet的方法即可。LinkedHashSet的源代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedHashSet&lt;E&gt;  </span><br><span class="line">    extends HashSet&lt;E&gt;  </span><br><span class="line">    implements Set&lt;E&gt;, Cloneable, java.io.Serializable &#123;  </span><br><span class="line">  </span><br><span class="line">    private static final long serialVersionUID = -2851667679971038690L;  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 构造一个带有指定初始容量和加载因子的新空链接哈希set。 </span><br><span class="line">     * </span><br><span class="line">     * 底层会调用父类的构造方法，构造一个有指定初始容量和加载因子的LinkedHashMap实例。 </span><br><span class="line">     * @param initialCapacity 初始容量。 </span><br><span class="line">     * @param loadFactor 加载因子。 </span><br><span class="line">     */  </span><br><span class="line">    public LinkedHashSet(int initialCapacity, float loadFactor) &#123;  </span><br><span class="line">        super(initialCapacity, loadFactor, true);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 构造一个带指定初始容量和默认加载因子0.75的新空链接哈希set。 </span><br><span class="line">     * </span><br><span class="line">     * 底层会调用父类的构造方法，构造一个带指定初始容量和默认加载因子0.75的LinkedHashMap实例。 </span><br><span class="line">     * @param initialCapacity 初始容量。 </span><br><span class="line">     */  </span><br><span class="line">    public LinkedHashSet(int initialCapacity) &#123;  </span><br><span class="line">        super(initialCapacity, .75f, true);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 构造一个带默认初始容量16和加载因子0.75的新空链接哈希set。 </span><br><span class="line">     * </span><br><span class="line">     * 底层会调用父类的构造方法，构造一个带默认初始容量16和加载因子0.75的LinkedHashMap实例。 </span><br><span class="line">     */  </span><br><span class="line">    public LinkedHashSet() &#123;  </span><br><span class="line">        super(16, .75f, true);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 构造一个与指定collection中的元素相同的新链接哈希set。 </span><br><span class="line">     *  </span><br><span class="line">     * 底层会调用父类的构造方法，构造一个足以包含指定collection </span><br><span class="line">     * 中所有元素的初始容量和加载因子为0.75的LinkedHashMap实例。 </span><br><span class="line">     * @param c 其中的元素将存放在此set中的collection。 </span><br><span class="line">     */  </span><br><span class="line">    public LinkedHashSet(Collection&lt;? extends E&gt; c) &#123;  </span><br><span class="line">        super(Math.max(2*c.size(), 11), .75f, true);  </span><br><span class="line">        addAll(c);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp; 在父类HashSet中，专为LinkedHashSet提供的构造方法如下，该方法为包访问权限，并未对外公开。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line">     * 以指定的initialCapacity和loadFactor构造一个新的空链接哈希集合。 </span><br><span class="line">     * 此构造函数为包访问权限，不对外公开，实际只是是对LinkedHashSet的支持。 </span><br><span class="line">     * </span><br><span class="line">     * 实际底层会以指定的参数构造一个空LinkedHashMap实例来实现。 </span><br><span class="line">     * @param initialCapacity 初始容量。 </span><br><span class="line">     * @param loadFactor 加载因子。 </span><br><span class="line">     * @param dummy 标记。 </span><br><span class="line">     */  </span><br><span class="line">    HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123;  </span><br><span class="line">    map = new LinkedHashMap&lt;E,Object&gt;(initialCapacity, loadFactor);  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;由上述源代码可见，LinkedHashSet通过继承HashSet，底层使用LinkedHashMap，以很简单明了的方式来实现了其自身的所有功能。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://weiyuanbiao.cn/java/java 高级系列/4.HashSet的实现原理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sherwin Wei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序员Sherwin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/java/java 高级系列/4.HashSet的实现原理/" class="post-title-link" itemprop="url">4.HashSet的实现原理</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-06-05 16:08:28" itemprop="dateCreated datePublished" datetime="2018-06-05T16:08:28+08:00">2018-06-05</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-01-23 17:11:07" itemprop="dateModified" datetime="2019-01-23T17:11:07+08:00">2019-01-23</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/java高级系列/" itemprop="url" rel="index"><span itemprop="name">java高级系列</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-HashSet概述："><a href="#1-HashSet概述：" class="headerlink" title="1.    HashSet概述："></a>1.    HashSet概述：</h3><p>&emsp;&emsp; HashSet实现Set接口，由哈希表（实际上是一个HashMap实例）支持。它不保证set 的迭代顺序；特别是它不保证该顺序恒久不变。此类允许使用null元素。</p>
<h3 id="2-HashSet的实现："><a href="#2-HashSet的实现：" class="headerlink" title="2.    HashSet的实现："></a>2.    HashSet的实现：</h3><p>&emsp;&emsp; 对于HashSet而言，它是基于HashMap实现的，HashSet底层使用HashMap来保存所有元素，因此HashSet 的实现比较简单，相关HashSet的操作，基本上都是直接调用底层HashMap的相关方法来完成， HashSet的源代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line">public class HashSet&lt;E&gt;  </span><br><span class="line">    extends AbstractSet&lt;E&gt;  </span><br><span class="line">    implements Set&lt;E&gt;, Cloneable, java.io.Serializable  </span><br><span class="line">&#123;  </span><br><span class="line">    static final long serialVersionUID = -5024744406713321676L;  </span><br><span class="line">  </span><br><span class="line">    // 底层使用HashMap来保存HashSet中所有元素。  </span><br><span class="line">    private transient HashMap&lt;E,Object&gt; map;  </span><br><span class="line">      </span><br><span class="line">    // 定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。  </span><br><span class="line">    private static final Object PRESENT = new Object();  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 默认的无参构造器，构造一个空的HashSet。 </span><br><span class="line">     *  </span><br><span class="line">     * 实际底层会初始化一个空的HashMap，并使用默认初始容量为16和加载因子0.75。 </span><br><span class="line">     */  </span><br><span class="line">    public HashSet() &#123;  </span><br><span class="line">    map = new HashMap&lt;E,Object&gt;();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 构造一个包含指定collection中的元素的新set。 </span><br><span class="line">     * </span><br><span class="line">     * 实际底层使用默认的加载因子0.75和足以包含指定 </span><br><span class="line">     * collection中所有元素的初始容量来创建一个HashMap。 </span><br><span class="line">     * @param c 其中的元素将存放在此set中的collection。 </span><br><span class="line">     */  </span><br><span class="line">    public HashSet(Collection&lt;? extends E&gt; c) &#123;  </span><br><span class="line">    map = new HashMap&lt;E,Object&gt;(Math.max((int) (c.size()/.75f) + 1, 16));  </span><br><span class="line">    addAll(c);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 以指定的initialCapacity和loadFactor构造一个空的HashSet。 </span><br><span class="line">     * </span><br><span class="line">     * 实际底层以相应的参数构造一个空的HashMap。 </span><br><span class="line">     * @param initialCapacity 初始容量。 </span><br><span class="line">     * @param loadFactor 加载因子。 </span><br><span class="line">     */  </span><br><span class="line">    public HashSet(int initialCapacity, float loadFactor) &#123;  </span><br><span class="line">    map = new HashMap&lt;E,Object&gt;(initialCapacity, loadFactor);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 以指定的initialCapacity构造一个空的HashSet。 </span><br><span class="line">     * </span><br><span class="line">     * 实际底层以相应的参数及加载因子loadFactor为0.75构造一个空的HashMap。 </span><br><span class="line">     * @param initialCapacity 初始容量。 </span><br><span class="line">     */  </span><br><span class="line">    public HashSet(int initialCapacity) &#123;  </span><br><span class="line">    map = new HashMap&lt;E,Object&gt;(initialCapacity);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 以指定的initialCapacity和loadFactor构造一个新的空链接哈希集合。 </span><br><span class="line">     * 此构造函数为包访问权限，不对外公开，实际只是是对LinkedHashSet的支持。 </span><br><span class="line">     * </span><br><span class="line">     * 实际底层会以指定的参数构造一个空LinkedHashMap实例来实现。 </span><br><span class="line">     * @param initialCapacity 初始容量。 </span><br><span class="line">     * @param loadFactor 加载因子。 </span><br><span class="line">     * @param dummy 标记。 </span><br><span class="line">     */  </span><br><span class="line">    HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123;  </span><br><span class="line">    map = new LinkedHashMap&lt;E,Object&gt;(initialCapacity, loadFactor);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 返回对此set中元素进行迭代的迭代器。返回元素的顺序并不是特定的。 </span><br><span class="line">     *  </span><br><span class="line">     * 底层实际调用底层HashMap的keySet来返回所有的key。 </span><br><span class="line">     * 可见HashSet中的元素，只是存放在了底层HashMap的key上， </span><br><span class="line">     * value使用一个static final的Object对象标识。 </span><br><span class="line">     * @return 对此set中元素进行迭代的Iterator。 </span><br><span class="line">     */  </span><br><span class="line">    public Iterator&lt;E&gt; iterator() &#123;  </span><br><span class="line">    return map.keySet().iterator();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 返回此set中的元素的数量（set的容量）。 </span><br><span class="line">     * </span><br><span class="line">     * 底层实际调用HashMap的size()方法返回Entry的数量，就得到该Set中元素的个数。 </span><br><span class="line">     * @return 此set中的元素的数量（set的容量）。 </span><br><span class="line">     */  </span><br><span class="line">    public int size() &#123;  </span><br><span class="line">    return map.size();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 如果此set不包含任何元素，则返回true。 </span><br><span class="line">     * </span><br><span class="line">     * 底层实际调用HashMap的isEmpty()判断该HashSet是否为空。 </span><br><span class="line">     * @return 如果此set不包含任何元素，则返回true。 </span><br><span class="line">     */  </span><br><span class="line">    public boolean isEmpty() &#123;  </span><br><span class="line">    return map.isEmpty();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 如果此set包含指定元素，则返回true。 </span><br><span class="line">     * 更确切地讲，当且仅当此set包含一个满足(o==null ? e==null : o.equals(e)) </span><br><span class="line">     * 的e元素时，返回true。 </span><br><span class="line">     * </span><br><span class="line">     * 底层实际调用HashMap的containsKey判断是否包含指定key。 </span><br><span class="line">     * @param o 在此set中的存在已得到测试的元素。 </span><br><span class="line">     * @return 如果此set包含指定元素，则返回true。 </span><br><span class="line">     */  </span><br><span class="line">    public boolean contains(Object o) &#123;  </span><br><span class="line">    return map.containsKey(o);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 如果此set中尚未包含指定元素，则添加指定元素。 </span><br><span class="line">     * 更确切地讲，如果此 set 没有包含满足(e==null ? e2==null : e.equals(e2)) </span><br><span class="line">     * 的元素e2，则向此set 添加指定的元素e。 </span><br><span class="line">     * 如果此set已包含该元素，则该调用不更改set并返回false。 </span><br><span class="line">     * </span><br><span class="line">     * 底层实际将将该元素作为key放入HashMap。 </span><br><span class="line">     * 由于HashMap的put()方法添加key-value对时，当新放入HashMap的Entry中key </span><br><span class="line">     * 与集合中原有Entry的key相同（hashCode()返回值相等，通过equals比较也返回true）， </span><br><span class="line">     * 新添加的Entry的value会将覆盖原来Entry的value，但key不会有任何改变， </span><br><span class="line">     * 因此如果向HashSet中添加一个已经存在的元素时，新添加的集合元素将不会被放入HashMap中， </span><br><span class="line">     * 原来的元素也不会有任何改变，这也就满足了Set中元素不重复的特性。 </span><br><span class="line">     * @param e 将添加到此set中的元素。 </span><br><span class="line">     * @return 如果此set尚未包含指定元素，则返回true。 </span><br><span class="line">     */  </span><br><span class="line">    public boolean add(E e) &#123;  </span><br><span class="line">    return map.put(e, PRESENT)==null;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 如果指定元素存在于此set中，则将其移除。 </span><br><span class="line">     * 更确切地讲，如果此set包含一个满足(o==null ? e==null : o.equals(e))的元素e， </span><br><span class="line">     * 则将其移除。如果此set已包含该元素，则返回true </span><br><span class="line">     * （或者：如果此set因调用而发生更改，则返回true）。（一旦调用返回，则此set不再包含该元素）。 </span><br><span class="line">     * </span><br><span class="line">     * 底层实际调用HashMap的remove方法删除指定Entry。 </span><br><span class="line">     * @param o 如果存在于此set中则需要将其移除的对象。 </span><br><span class="line">     * @return 如果set包含指定元素，则返回true。 </span><br><span class="line">     */  </span><br><span class="line">    public boolean remove(Object o) &#123;  </span><br><span class="line">    return map.remove(o)==PRESENT;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 从此set中移除所有元素。此调用返回后，该set将为空。 </span><br><span class="line">     * </span><br><span class="line">     * 底层实际调用HashMap的clear方法清空Entry中所有元素。 </span><br><span class="line">     */  </span><br><span class="line">    public void clear() &#123;  </span><br><span class="line">    map.clear();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 返回此HashSet实例的浅表副本：并没有复制这些元素本身。 </span><br><span class="line">     * </span><br><span class="line">     * 底层实际调用HashMap的clone()方法，获取HashMap的浅表副本，并设置到HashSet中。 </span><br><span class="line">     */  </span><br><span class="line">    public Object clone() &#123;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) super.clone();  </span><br><span class="line">            newSet.map = (HashMap&lt;E, Object&gt;) map.clone();  </span><br><span class="line">            return newSet;  </span><br><span class="line">        &#125; catch (CloneNotSupportedException e) &#123;  </span><br><span class="line">            throw new InternalError();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://weiyuanbiao.cn/java/java 高级系列/3.LinkedHashMap的实现原理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sherwin Wei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序员Sherwin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/java/java 高级系列/3.LinkedHashMap的实现原理/" class="post-title-link" itemprop="url">3.LinkedHashMap的实现原理</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-06-04 15:46:06" itemprop="dateCreated datePublished" datetime="2018-06-04T15:46:06+08:00">2018-06-04</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-01-23 17:11:07" itemprop="dateModified" datetime="2019-01-23T17:11:07+08:00">2019-01-23</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/java高级系列/" itemprop="url" rel="index"><span itemprop="name">java高级系列</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-LinkedHashMap概述："><a href="#1-LinkedHashMap概述：" class="headerlink" title="1. LinkedHashMap概述："></a>1. LinkedHashMap概述：</h3><p> &emsp; &emsp;  LinkedHashMap是Map接口的哈希表和链接列表实现，具有可预知的迭代顺序。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p>
<p>  &emsp; &emsp;  LinkedHashMap实现与HashMap的不同之处在于，前者维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。</p>
<ul>
<li>注意，此实现不是同步的。如果多个线程同时访问链接的哈希映射，而其中至少一个线程从结构上修改了该映射，则它必须保持外部同步。</li>
</ul>
<h3 id="2-LinkedHashMap的实现："><a href="#2-LinkedHashMap的实现：" class="headerlink" title="2. LinkedHashMap的实现："></a>2. LinkedHashMap的实现：</h3><p>  &emsp; &emsp; 对于LinkedHashMap而言，它继承与HashMap、底层使用哈希表与双向链表来保存所有元素。其基本操作与父类HashMap相似，它通过重写父类相关的方法，来实现自己的链接列表特性。下面我们来分析LinkedHashMap的源代码：</p>
<h4 id="1-Entry元素："><a href="#1-Entry元素：" class="headerlink" title="1) Entry元素："></a>1) Entry元素：</h4><p>  &emsp; &emsp; LinkedHashMap采用的hash算法和HashMap相同，但是它重新定义了数组中保存的元素Entry，该Entry除了保存当前对象的引用外，还保存了其上一个元素before和下一个元素after的引用，从而在哈希表的基础上又构成了双向链接列表。看源代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line"> * 双向链表的表头元素。 </span><br><span class="line"> */  </span><br><span class="line">private transient Entry&lt;K,V&gt; header;  </span><br><span class="line">  </span><br><span class="line">/** </span><br><span class="line"> * LinkedHashMap的Entry元素。 </span><br><span class="line"> * 继承HashMap的Entry元素，又保存了其上一个元素before和下一个元素after的引用。 </span><br><span class="line"> */  </span><br><span class="line">private static class Entry&lt;K,V&gt; extends HashMap.Entry&lt;K,V&gt; &#123;  </span><br><span class="line">    Entry&lt;K,V&gt; before, after;  </span><br><span class="line">    ……  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2-初始化："><a href="#2-初始化：" class="headerlink" title="2) 初始化："></a>2) 初始化：</h4><p>&emsp; &emsp; 通过源代码可以看出，在LinkedHashMap的构造方法中，实际调用了父类HashMap的相关构造方法来构造一个底层存放的table数组。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public LinkedHashMap(int initialCapacity, float loadFactor) &#123;  </span><br><span class="line">    super(initialCapacity, loadFactor);  </span><br><span class="line">    accessOrder = false;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>HashMap中的相关构造方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;  </span><br><span class="line">    if (initialCapacity &lt; 0)  </span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +  </span><br><span class="line">                                           initialCapacity);  </span><br><span class="line">    if (initialCapacity &gt; MAXIMUM_CAPACITY)  </span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;  </span><br><span class="line">    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))  </span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +  </span><br><span class="line">                                           loadFactor);  </span><br><span class="line">  </span><br><span class="line">    // Find a power of 2 &gt;= initialCapacity  </span><br><span class="line">    int capacity = 1;  </span><br><span class="line">    while (capacity &lt; initialCapacity)  </span><br><span class="line">        capacity &lt;&lt;= 1;  </span><br><span class="line">  </span><br><span class="line">    this.loadFactor = loadFactor;  </span><br><span class="line">    threshold = (int)(capacity * loadFactor);  </span><br><span class="line">    table = new Entry[capacity];  </span><br><span class="line">    init();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp; &emsp; 我们已经知道LinkedHashMap的Entry元素继承HashMap的Entry，提供了双向链表的功能。在上述HashMap的构造器<br>中，最后会调用init()方法，进行相关的初始化，这个方法在HashMap的实现中并无意义，只是提供给子类实现相关的初始化调用。</p>
<p>   &emsp; &emsp; LinkedHashMap重写了init()方法，在调用父类的构造方法完成构造后，进一步实现了对其元素Entry的初始化操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void init() &#123;  </span><br><span class="line">    header = new Entry&lt;K,V&gt;(-1, null, null, null);  </span><br><span class="line">    header.before = header.after = header;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-存储："><a href="#3-存储：" class="headerlink" title="3) 存储："></a>3) 存储：</h4><p> &emsp; &emsp;   LinkedHashMap并未重写父类HashMap的put方法，而是重写了父类HashMap的put方法调用的子方法void addEntry(int hash, K key, V value, int bucketIndex) 和void createEntry(int hash, K key, V value, int bucketIndex)，提供了自己特有的双向链接列表的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;  </span><br><span class="line">    // 调用create方法，将新元素以双向链表的的形式加入到映射中。  </span><br><span class="line">    createEntry(hash, key, value, bucketIndex);  </span><br><span class="line">  </span><br><span class="line">    // 删除最近最少使用元素的策略定义  </span><br><span class="line">    Entry&lt;K,V&gt; eldest = header.after;  </span><br><span class="line">    if (removeEldestEntry(eldest)) &#123;  </span><br><span class="line">        removeEntryForKey(eldest.key);  </span><br><span class="line">    &#125; else &#123;  </span><br><span class="line">        if (size &gt;= threshold)  </span><br><span class="line">            resize(2 * table.length);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">void createEntry(int hash, K key, V value, int bucketIndex) &#123;  </span><br><span class="line">    HashMap.Entry&lt;K,V&gt; old = table[bucketIndex];  </span><br><span class="line">    Entry&lt;K,V&gt; e = new Entry&lt;K,V&gt;(hash, key, value, old);  </span><br><span class="line">    table[bucketIndex] = e;  </span><br><span class="line">    // 调用元素的addBrefore方法，将元素加入到哈希、双向链接列表。  </span><br><span class="line">    e.addBefore(header);  </span><br><span class="line">    size++;  </span><br><span class="line">&#125;  </span><br><span class="line">private void addBefore(Entry&lt;K,V&gt; existingEntry) &#123;  </span><br><span class="line">    after  = existingEntry;  </span><br><span class="line">    before = existingEntry.before;  </span><br><span class="line">    before.after = this;  </span><br><span class="line">    after.before = this;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="4-读取："><a href="#4-读取：" class="headerlink" title="4) 读取："></a>4) 读取：</h4><p>   &emsp; &emsp; LinkedHashMap重写了父类HashMap的get方法，实际在调用父类getEntry()方法取得查找的元素后，再判断当排序模式accessOrder为true时，记录访问顺序，将最新访问的元素添加到双向链表的表头，并从原来的位置删除。由于的链表的增加、删除操作是常量级的，故并不会带来性能的损失。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;  </span><br><span class="line">    // 调用父类HashMap的getEntry()方法，取得要查找的元素。  </span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)getEntry(key);  </span><br><span class="line">    if (e == null)  </span><br><span class="line">        return null;  </span><br><span class="line">    // 记录访问顺序。  </span><br><span class="line">    e.recordAccess(this);  </span><br><span class="line">    return e.value;  </span><br><span class="line">&#125;  </span><br><span class="line">void recordAccess(HashMap&lt;K,V&gt; m) &#123;  </span><br><span class="line">    LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m;  </span><br><span class="line">    // 如果定义了LinkedHashMap的迭代顺序为访问顺序，  </span><br><span class="line">    // 则删除以前位置上的元素，并将最新访问的元素添加到链表表头。  </span><br><span class="line">    if (lm.accessOrder) &#123;  </span><br><span class="line">        lm.modCount++;  </span><br><span class="line">        remove();  </span><br><span class="line">        addBefore(lm.header);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="5-排序模式："><a href="#5-排序模式：" class="headerlink" title="5) 排序模式："></a>5) 排序模式：</h4><p>&emsp; &emsp; LinkedHashMap定义了排序模式accessOrder，该属性为boolean型变量，对于访问顺序，为true；对于插入顺序，则为false。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br><span class="line"><span class="comment">//一般情况下，不必指定排序模式，其迭代顺序即为默认为插入顺序。看LinkedHashMap的构造方法，如：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);  </span><br><span class="line">    accessOrder = <span class="keyword">false</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp; &emsp; 这些构造方法都会默认指定排序模式为插入顺序。如果你想构造一个LinkedHashMap，并打算按从近期访问最少到近期访问最多的顺序（即访问顺序）来保存元素，那么请使用下面的构造方法构造LinkedHashMap：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public LinkedHashMap(int initialCapacity,  </span><br><span class="line">         float loadFactor,  </span><br><span class="line">                     boolean accessOrder) &#123;  </span><br><span class="line">    super(initialCapacity, loadFactor);  </span><br><span class="line">    this.accessOrder = accessOrder;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> &emsp; &emsp; 该哈希映射的迭代顺序就是最后访问其条目的顺序，这种映射很适合构建LRU缓存。LinkedHashMap提供了removeEldestEntry(Map.Entry&lt;K,V&gt; eldest)方法，在将新条目插入到映射后，put和 putAll将调用此方法。该方法可以提供在每次添加新条目时移除最旧条目的实现程序，默认返回false，这样，此映射的行为将类似于正常映射，即永远不能移除最旧的元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) &#123;  </span><br><span class="line">    return false;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> &emsp; &emsp; 此方法通常不以任何方式修改映射，相反允许映射在其返回值的指引下进行自我修改。如果用此映射构建LRU缓存(LRU是Least Recently Used的缩写，即最近最少使用，常用于页面置换算法.)，则非常方便，它允许映射通过删除旧条目来减少内存损耗。<br>   例如：重写此方法，维持此映射只保存100个条目的稳定状态，在每次添加新条目时删除最旧的条目。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private static final int MAX_ENTRIES = 100;  </span><br><span class="line">protected boolean removeEldestEntry(Map.Entry eldest) &#123;  </span><br><span class="line">    return size() &gt; MAX_ENTRIES;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://weiyuanbiao.cn/java/java 高级系列/2.HashMap的实现原理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sherwin Wei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序员Sherwin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/java/java 高级系列/2.HashMap的实现原理/" class="post-title-link" itemprop="url">2.HashMap的实现原理</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-06-02 09:37:25" itemprop="dateCreated datePublished" datetime="2018-06-02T09:37:25+08:00">2018-06-02</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-01-23 17:11:07" itemprop="dateModified" datetime="2019-01-23T17:11:07+08:00">2019-01-23</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/java高级系列/" itemprop="url" rel="index"><span itemprop="name">java高级系列</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-HashMap概述："><a href="#1-HashMap概述：" class="headerlink" title="1.HashMap概述："></a>1.HashMap概述：</h3><p> &emsp; &emsp; HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p>
<h3 id="2-HashMap的数据结构："><a href="#2-HashMap的数据结构：" class="headerlink" title="2.HashMap的数据结构："></a>2.HashMap的数据结构：</h3><p> &emsp;&emsp;  在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</p>
<p> <img src="http://p5zbw6dku.bkt.clouddn.com/18-3-22/3994350.jpg" alt="image"></p>
<p>   从上图中可以看出，HashMap底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个HashMap的时候，就会初始化一个数组。<br>   源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * The table, resized as necessary. Length MUST Always be a power of two. </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">transient</span> Entry[] table;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;  </span><br><span class="line"><span class="keyword">final</span> K key;  </span><br><span class="line">V value;  </span><br><span class="line">Entry&lt;K,V&gt; next;  </span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> hash;  </span><br><span class="line">……  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;可以看出，Entry就是数组中的元素，每个 Map.Entry 其实就是一个key-value对，它持有一个指向下一个元素的引用，这就构成了链表。</p>
<h3 id="3-HashMap的存取实现："><a href="#3-HashMap的存取实现：" class="headerlink" title="3.HashMap的存取实现："></a>3.HashMap的存取实现：</h3><h4 id="1-存储："><a href="#1-存储：" class="headerlink" title="1) 存储："></a>1) 存储：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;  </span><br><span class="line"><span class="comment">// HashMap允许存放null键和null值。  </span></span><br><span class="line"><span class="comment">// 当key为null时，调用putForNullKey方法，将value放置在数组第一个位置。  </span></span><br><span class="line"><span class="keyword">if</span> (key == <span class="keyword">null</span>)  </span><br><span class="line"><span class="keyword">return</span> putForNullKey(value);  </span><br><span class="line"><span class="comment">// 根据key的keyCode重新计算hash值。  </span></span><br><span class="line"><span class="keyword">int</span> hash = hash(key.hashCode());  </span><br><span class="line"><span class="comment">// 搜索指定hash值在对应table中的索引。  </span></span><br><span class="line"><span class="keyword">int</span> i = indexFor(hash, table.length);  </span><br><span class="line"><span class="comment">// 如果 i 索引处的 Entry 不为 null，通过循环不断遍历 e 元素的下一个元素。  </span></span><br><span class="line"><span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;  </span><br><span class="line">Object k;  </span><br><span class="line"><span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;  </span><br><span class="line">V oldValue = e.value;  </span><br><span class="line">e.value = value;  </span><br><span class="line">e.recordAccess(<span class="keyword">this</span>);  </span><br><span class="line"><span class="keyword">return</span> oldValue;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 如果i索引处的Entry为null，表明此处还没有Entry。  </span></span><br><span class="line">modCount++;  </span><br><span class="line"><span class="comment">// 将key、value添加到i索引处。  </span></span><br><span class="line">addEntry(hash, key, value, i);  </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从上面的源代码中可以看出：当我们往HashMap中put元素的时候，先根据key的hashCode重新计算hash值，根据hash值得到这个元素在数组中的位置（即下标），如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。</p>
<p> &emsp;&emsp;  addEntry(hash, key, value, i)方法根据计算出的hash值，将key-value对放在数组table的i索引处。addEntry 是 HashMap 提供的一个包访问权限的方法，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;  </span><br><span class="line">// 获取指定 bucketIndex 索引处的 Entry   </span><br><span class="line">Entry&lt;K,V&gt; e = table[bucketIndex];  </span><br><span class="line">// 将新创建的 Entry 放入 bucketIndex 索引处，并让新的 Entry 指向原来的 Entry  </span><br><span class="line">table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e);  </span><br><span class="line">// 如果 Map 中的 key-value 对的数量超过了极限  </span><br><span class="line">if (size++ &gt;= threshold)  </span><br><span class="line">// 把 table 对象的长度扩充到原来的2倍。  </span><br><span class="line">resize(2 * table.length);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> &emsp;&emsp; 当系统决定存储HashMap中的key-value对时，完全没有考虑Entry中的value，仅仅只是根据key来计算并决定每个Entry的存储位置。我们完全可以把 Map 集合中的 value 当成 key 的附属，当系统决定了 key 的存储位置之后，value 随之保存在那里即可。</p>
<p> &emsp;&emsp;  hash(int h)方法根据key的hashCode重新计算一次散列。此算法加入了高位计算，防止低位不变，高位变化时，造成的hash冲突。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;  </span><br><span class="line">h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);  </span><br><span class="line"><span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp; 我们可以看到在HashMap中要找到某个元素，需要根据key的hash值来求得对应数组中的位置。如何计算这个位置就是hash算法。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的 元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表，这样就大大优化了查询的效率。</p>
<p>&emsp;&emsp; 对于任意给定的对象，只要它的 hashCode() 返回值相同，那么程序调用 hash(int h) 方法所计算得到的 hash 码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，“模”运算的消耗还是比较大的，在HashMap中是这样做的：调用 indexFor(int h, int length) 方法来计算该对象应该保存在 table 数组的哪个索引处。indexFor(int h, int length) 方法的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;  </span><br><span class="line"><span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这个方法非常巧妙，它通过 h &amp; (table.length -1) 来得到该对象的保存位，而HashMap底层数组的长度总是 2 的 n 次方，这是HashMap在速度上的优化。在 HashMap 构造器中有如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> capacity = <span class="number">1</span>;  </span><br><span class="line"><span class="keyword">while</span> (capacity &lt; initialCapacity)  </span><br><span class="line">capacity &lt;&lt;= <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>   这段代码保证初始化时HashMap的容量总是2的n次方，即底层数组的长度总是为2的n次方。<br>当length总是 2 的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。<br>   这看上去很简单，其实比较有玄机的，我们举个例子来说明：<br>   假设数组长度分别为15和16，优化后的hash码分别为8和9，那么&amp;运算后的结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">h &amp; (table.length-1) hash table.length-1</span><br><span class="line">8 &amp; (15-1)： 0100   &amp;  1110   =0100</span><br><span class="line">9 &amp; (15-1)： 0101   &amp;  1110   =0100</span><br><span class="line">-----------------------------------------------------------------------------------------------------------------------</span><br><span class="line">8 &amp; (16-1)： 0100   &amp;  1111   =0100</span><br><span class="line">9 &amp; (16-1)： 0101   &amp;  1111   =0101</span><br></pre></td></tr></table></figure></p>
<p> &emsp;&emsp;  从上面的例子中可以看出：当它们和15-1（1110）“与”的时候，产生了相同的结果，也就是说它们会定位到数组中的同一个位置上去，这就产生了碰撞，8和9会被放到数组中的同一个位置上形成链表，那么查询的时候就需要遍历这个链 表，得到8或者9，这样就降低了查询的效率。同时，我们也可以发现，当数组长度为15的时候，hash值会与15-1（1110）进行“与”，那么 最后一位永远是0，而0001，0011，0101，1001，1011，0111，1101这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！而当数组长度为16时，即为2的n次方时，2n-1得到的二进制数的每个位上的值都为1，这使得在低位上&amp;时，得到的和原hash的低位相同，加之hash(int h)方法对key的hashCode的进一步优化，加入了高位计算，就使得只有相同的hash值的两个值才会被放到数组中的同一个位置上形成链表。</p>
<p> &emsp;&emsp;  所以说，当数组长度为2的n次幂的时候，不同的key算得得index相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。</p>
<p> &emsp;&emsp;  根据上面 put 方法的源代码可以看出，当程序试图将一个key-value对放入HashMap中时，程序首先根据该 key 的 hashCode() 返回值决定该 Entry 的存储位置：如果两个 Entry 的 key 的 hashCode() 返回值相同，那它们的存储位置相同。如果这两个 Entry 的 key 通过 equals 比较返回 true，新添加 Entry 的 value 将覆盖集合中原有 Entry 的 value，但key不会覆盖。如果这两个 Entry 的 key 通过 equals 比较返回 false，新添加的 Entry 将与集合中原有 Entry 形成 Entry 链，而且新添加的 Entry 位于 Entry 链的头部——具体说明继续看 addEntry() 方法的说明。</p>
<h4 id="2-读取："><a href="#2-读取：" class="headerlink" title="2) 读取："></a>2) 读取：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;  </span><br><span class="line"><span class="keyword">if</span> (key == <span class="keyword">null</span>)  </span><br><span class="line"><span class="keyword">return</span> getForNullKey();  </span><br><span class="line"><span class="keyword">int</span> hash = hash(key.hashCode());  </span><br><span class="line"><span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];  </span><br><span class="line">e != <span class="keyword">null</span>;  </span><br><span class="line">e = e.next) &#123;  </span><br><span class="line">Object k;  </span><br><span class="line"><span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))  </span><br><span class="line"><span class="keyword">return</span> e.value;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;   有了上面存储时的hash算法作为基础，理解起来这段代码就很容易了。从上面的源代码中可以看出：从HashMap中get元素时，首先计算key的hashCode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。</p>
<h4 id="3-归纳起来简单地说"><a href="#3-归纳起来简单地说" class="headerlink" title="3) 归纳起来简单地说"></a>3) 归纳起来简单地说</h4><p>&emsp;&emsp; HashMap 在底层将 key-value 当成一个整体进行处理，这个整体就是一个 Entry 对象。HashMap 底层采用一个 Entry[] 数组来保存所有的 key-value 对，当需要存储一个 Entry 对象时，会根据hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Entry时，也会根据hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Entry。</p>
<h3 id="4-HashMap的resize（rehash）："><a href="#4-HashMap的resize（rehash）：" class="headerlink" title="4.HashMap的resize（rehash）："></a>4.HashMap的resize（rehash）：</h3><p> &emsp;&emsp;  当HashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，因为数组的长度是固定的。所以为了提高查询的效率，就要对HashMap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，这是一个常用的操作，而在HashMap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。</p>
<p> &emsp;&emsp;  那么HashMap什么时候进行扩容呢？当HashMap中的元素个数超过数组大小<em>loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，这是一个折中的取值。也就是说，默认情况下，数组大小为16，那么当HashMap中元素个数超过16</em>0.75=12的时候，就把数组的大小扩展为 2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。</p>
<h3 id="5-HashMap的性能参数："><a href="#5-HashMap的性能参数：" class="headerlink" title="5.HashMap的性能参数："></a>5.HashMap的性能参数：</h3><ul>
<li><p>HashMap 包含如下几个构造器：</p>
</li>
<li><p>HashMap()：构建一个初始容量为 16，负载因子为 0.75 的 HashMap。</p>
</li>
<li>HashMap(int initialCapacity)：构建一个初始容量为 initialCapacity，负载因子为 0.75 的 HashMap。</li>
<li>HashMap(int initialCapacity, float loadFactor)：以指定初始容量、指定的负载因子创建一个 HashMap。</li>
<li>HashMap的基础构造器HashMap(int initialCapacity, float loadFactor)带有两个参数，它们是初始容量initialCapacity和加载因子loadFactor。</li>
<li>initialCapacity：HashMap的最大容量，即为底层数组的长度。</li>
<li><p>loadFactor：负载因子loadFactor定义为：散列表的实际元素数目(n)/ 散列表的容量(m)。<br>负载因子衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之愈小。对于使用链表法的散列表来说，查找一个元素的平均时间是O(1+a)，因此如果负载因子越大，对空间的利用更充分，然而后果是查找效率的降低；如果负载因子太小，那么散列表的数据将过于稀疏，对空间造成严重浪费。<br>&emsp;&emsp; HashMap的实现中，通过threshold字段来判断HashMap的最大容量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threshold = (<span class="keyword">int</span>)(capacity * loadFactor);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<br>结合负载因子的定义公式可知，threshold就是在此loadFactor和capacity对应下允许的最大元素数目，超过这个数目就重新resize，以降低实际的负载因子。默认的的负载因子0.75是对空间和时间效率的一个平衡选择。当容量超出此最大容量时， resize后的HashMap容量是容量的两倍：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (size++ &gt;= threshold) </span><br><span class="line">resize(<span class="number">2</span> * table.length);</span><br></pre></td></tr></table></figure>
<h3 id="6-Fail-Fast机制："><a href="#6-Fail-Fast机制：" class="headerlink" title="6.Fail-Fast机制："></a>6.Fail-Fast机制：</h3><p>&emsp;&emsp;我们知道java.util.HashMap不是线程安全的，因此如果在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。</p>
<p>&emsp;&emsp;这一策略在源码中的实现是通过modCount域，modCount顾名思义就是修改次数，对HashMap内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HashIterator() &#123;  </span><br><span class="line">expectedModCount = modCount;  </span><br><span class="line">if (size &gt; 0) &#123; // advance to first entry  </span><br><span class="line">Entry[] t = table;  </span><br><span class="line">while (index &lt; t.length &amp;&amp; (next = t[index++]) == null)  </span><br><span class="line">;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map：</p>
<ul>
<li><p>注意到modCount声明为volatile，保证线程之间修改的可见性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final Entry&lt;K,V&gt; nextEntry() &#123; </span><br><span class="line">if (modCount != expectedModCount) </span><br><span class="line">throw new ConcurrentModificationException();</span><br></pre></td></tr></table></figure>
<ul>
<li>在HashMap的API中指出：<br>&emsp;&emsp;由所有HashMap类的“collection 视图方法”所返回的迭代器都是快速失败的：在迭代器创建之后，如果从结构上对映射进行修改，除非通过迭代器本身的 remove 方法，其他任何时间任何方式的修改，迭代器都将抛出 ConcurrentModificationException。因此，面对并发的修改，迭代器很快就会完全失败，而不冒在将来不确定的时间发生任意不确定行为的风险。</li>
<li>注意，迭代器的快速失败行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出 ConcurrentModificationException。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测程序错误。</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://weiyuanbiao.cn/java/java 高级系列/1.ArrayList的实现原理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sherwin Wei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序员Sherwin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/java/java 高级系列/1.ArrayList的实现原理/" class="post-title-link" itemprop="url">1.ArrayList的实现原理</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-06-01 09:03:02" itemprop="dateCreated datePublished" datetime="2018-06-01T09:03:02+08:00">2018-06-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-01-23 17:11:07" itemprop="dateModified" datetime="2019-01-23T17:11:07+08:00">2019-01-23</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/java高级系列/" itemprop="url" rel="index"><span itemprop="name">java高级系列</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-ArrayList概述："><a href="#1-ArrayList概述：" class="headerlink" title="1. ArrayList概述："></a>1. ArrayList概述：</h3><p>&emsp;&emsp; ArrayList是List接口的可变数组的实现。实现了所有可选列表操作，并允许包括 null 在内的所有元素。除了实现 List 接口外，此类还提供一些方法来操作内部用来存储列表的数组的大小。</p>
<p>&emsp;&emsp; 每个ArrayList实例都有一个容量，该容量是指用来存储列表元素的数组的大小。它总是至少等于列表的大小。随着向ArrayList中不断添加元素，其容量也自动增长。自动增长会带来数据向新数组的重新拷贝，因此，如果可预知数据量的多少，可在构造ArrayList时指定其容量。在添加大量元素前，应用程序也可以使用ensureCapacity操作来增加ArrayList实例的容量，这可以减少递增式再分配的数量。 </p>
<ul>
<li>注意，此实现不是同步的。如果多个线程同时访问一个ArrayList实例，而其中至少一个线程从结构上修改了列表，那么它必须保持外部同步。</li>
</ul>
<h3 id="2-ArrayList的实现："><a href="#2-ArrayList的实现：" class="headerlink" title="2. ArrayList的实现："></a>2. ArrayList的实现：</h3><p>&emsp;&emsp; 对于ArrayList而言，它实现List接口、底层使用数组保存所有元素。其操作基本上是对数组的操作。下面我们来分析ArrayList的源代码：</p>
<h4 id="1-底层使用数组实现："><a href="#1-底层使用数组实现：" class="headerlink" title="1) 底层使用数组实现："></a>1) 底层使用数组实现：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private transient Object[] elementData;</span><br></pre></td></tr></table></figure>
<h4 id="2-构造方法："><a href="#2-构造方法：" class="headerlink" title="2) 构造方法："></a>2) 构造方法：</h4><p> &emsp;&emsp;  ArrayList提供了三种方式的构造器，可以构造一个默认初始容量为10的空列表、构造一个指定初始容量的空列表以及构造一个包含指定collection的元素的列表，这些元素按照该collection的迭代器返回它们的顺序排列的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList() &#123;  </span><br><span class="line">    this(10);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">public ArrayList(int initialCapacity) &#123;  </span><br><span class="line">    super();  </span><br><span class="line">    if (initialCapacity &lt; 0)  </span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity);  </span><br><span class="line">    this.elementData = new Object[initialCapacity];  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">public ArrayList(Collection&lt;? extends E&gt; c) &#123;  </span><br><span class="line">    elementData = c.toArray();  </span><br><span class="line">    size = elementData.length;  </span><br><span class="line">    // c.toArray might (incorrectly) not return Object[] (see 6260652)  </span><br><span class="line">    if (elementData.getClass() != Object[].class)  </span><br><span class="line">        elementData = Arrays.copyOf(elementData, size, Object[].class);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-存储："><a href="#3-存储：" class="headerlink" title="3) 存储："></a>3) 存储：</h4><p>&emsp;&emsp; ArrayList提供了set(int index, E element)、add(E e)、add(int index, E element)、addAll(Collection&lt;? extends E&gt; c)、addAll(int index, Collection&lt;? extends E&gt; c)这些添加元素的方法。下面我们一一讲解：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">// 用指定的元素替代此列表中指定位置上的元素，并返回以前位于该位置上的元素。  </span><br><span class="line">public E set(int index, E element) &#123;  </span><br><span class="line">    RangeCheck(index);  </span><br><span class="line">  </span><br><span class="line">    E oldValue = (E) elementData[index];  </span><br><span class="line">    elementData[index] = element;  </span><br><span class="line">    return oldValue;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">// 将指定的元素添加到此列表的尾部。  </span><br><span class="line">public boolean add(E e) &#123;  </span><br><span class="line">    ensureCapacity(size + 1);   </span><br><span class="line">    elementData[size++] = e;  </span><br><span class="line">    return true;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">// 将指定的元素插入此列表中的指定位置。  </span><br><span class="line">// 如果当前位置有元素，则向右移动当前位于该位置的元素以及所有后续元素（将其索引加1）。  </span><br><span class="line">public void add(int index, E element) &#123;  </span><br><span class="line">    if (index &gt; size || index &lt; 0)  </span><br><span class="line">        throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+&quot;, Size: &quot;+size);  </span><br><span class="line">    // 如果数组长度不足，将进行扩容。  </span><br><span class="line">    ensureCapacity(size+1);  // Increments modCount!!  </span><br><span class="line">    // 将 elementData中从Index位置开始、长度为size-index的元素，  </span><br><span class="line">    // 拷贝到从下标为index+1位置开始的新的elementData数组中。  </span><br><span class="line">    // 即将当前位于该位置的元素以及所有后续元素右移一个位置。  </span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + 1, size - index);  </span><br><span class="line">    elementData[index] = element;  </span><br><span class="line">    size++;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">// 按照指定collection的迭代器所返回的元素顺序，将该collection中的所有元素添加到此列表的尾部。  </span><br><span class="line">public boolean addAll(Collection&lt;? extends E&gt; c) &#123;  </span><br><span class="line">    Object[] a = c.toArray();  </span><br><span class="line">    int numNew = a.length;  </span><br><span class="line">    ensureCapacity(size + numNew);  // Increments modCount  </span><br><span class="line">    System.arraycopy(a, 0, elementData, size, numNew);  </span><br><span class="line">    size += numNew;  </span><br><span class="line">    return numNew != 0;  </span><br><span class="line">&#125;  </span><br><span class="line">// 从指定的位置开始，将指定collection中的所有元素插入到此列表中。  </span><br><span class="line">public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;  </span><br><span class="line">    if (index &gt; size || index &lt; 0)  </span><br><span class="line">        throw new IndexOutOfBoundsException(  </span><br><span class="line">            &quot;Index: &quot; + index + &quot;, Size: &quot; + size);  </span><br><span class="line">  </span><br><span class="line">    Object[] a = c.toArray();  </span><br><span class="line">    int numNew = a.length;  </span><br><span class="line">    ensureCapacity(size + numNew);  // Increments modCount  </span><br><span class="line">  </span><br><span class="line">    int numMoved = size - index;  </span><br><span class="line">    if (numMoved &gt; 0)  </span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + numNew, numMoved);  </span><br><span class="line">  </span><br><span class="line">    System.arraycopy(a, 0, elementData, index, numNew);  </span><br><span class="line">    size += numNew;  </span><br><span class="line">    return numNew != 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="4-读取："><a href="#4-读取：" class="headerlink" title="4) 读取："></a>4) 读取：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 返回此列表中指定位置上的元素。  </span><br><span class="line">public E get(int index) &#123;  </span><br><span class="line">    RangeCheck(index);  </span><br><span class="line">  </span><br><span class="line">    return (E) elementData[index];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-删除："><a href="#5-删除：" class="headerlink" title="5) 删除："></a>5) 删除：</h4><p>   ArrayList提供了根据下标或者指定对象两种方式的删除功能。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 移除此列表中指定位置上的元素。  </span><br><span class="line">public E remove(int index) &#123;  </span><br><span class="line">    RangeCheck(index);  </span><br><span class="line">  </span><br><span class="line">    modCount++;  </span><br><span class="line">    E oldValue = (E) elementData[index];  </span><br><span class="line">  </span><br><span class="line">    int numMoved = size - index - 1;  </span><br><span class="line">    if (numMoved &gt; 0)  </span><br><span class="line">        System.arraycopy(elementData, index+1, elementData, index, numMoved);  </span><br><span class="line">    elementData[--size] = null; // Let gc do its work  </span><br><span class="line">  </span><br><span class="line">    return oldValue;  </span><br><span class="line">&#125;  </span><br><span class="line">// 移除此列表中首次出现的指定元素（如果存在）。这是应为ArrayList中允许存放重复的元素。  </span><br><span class="line">public boolean remove(Object o) &#123;  </span><br><span class="line">    // 由于ArrayList中允许存放null，因此下面通过两种情况来分别处理。  </span><br><span class="line">    if (o == null) &#123;  </span><br><span class="line">        for (int index = 0; index &lt; size; index++)  </span><br><span class="line">            if (elementData[index] == null) &#123;  </span><br><span class="line">                // 类似remove(int index)，移除列表中指定位置上的元素。  </span><br><span class="line">                fastRemove(index);  </span><br><span class="line">                return true;  </span><br><span class="line">            &#125;  </span><br><span class="line">&#125; else &#123;  </span><br><span class="line">    for (int index = 0; index &lt; size; index++)  </span><br><span class="line">        if (o.equals(elementData[index])) &#123;  </span><br><span class="line">            fastRemove(index);  </span><br><span class="line">            return true;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return false;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>注意：从数组中移除元素的操作，也会导致被移除的元素以后的所有元素的向左移动一个位置。<h4 id="6-调整数组容量："><a href="#6-调整数组容量：" class="headerlink" title="6) 调整数组容量："></a>6) 调整数组容量：</h4>&emsp;&emsp; 从上面介绍的向ArrayList中存储元素的代码中，我们看到，每当向数组中添加元素时，都要去检查添加后元素的个数是否会超出当前数组的长度，如果超出，数组将会进行扩容，以满足添加数据的需求。数组扩容通过一个公开的方法ensureCapacity(int minCapacity)来实现。在实际添加大量元素前，我也可以使用ensureCapacity来手动增加ArrayList实例的容量，以减少递增式再分配的数量。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void ensureCapacity(int minCapacity) &#123;  </span><br><span class="line">    modCount++;  </span><br><span class="line">    int oldCapacity = elementData.length;  </span><br><span class="line">    if (minCapacity &gt; oldCapacity) &#123;  </span><br><span class="line">        Object oldData[] = elementData;  </span><br><span class="line">        int newCapacity = (oldCapacity * 3)/2 + 1;  </span><br><span class="line">            if (newCapacity &lt; minCapacity)  </span><br><span class="line">                newCapacity = minCapacity;  </span><br><span class="line">      // minCapacity is usually close to size, so this is a win:  </span><br><span class="line">      elementData = Arrays.copyOf(elementData, newCapacity);  //对于数组里面的元素是复杂Object的时候是浅拷贝</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>&emsp;&emsp;从上述代码中可以看出，数组进行扩容时，会将老数组中的元素重新拷贝一份到新的数组中，每次数组容量的增长大约是其原容量的1.5倍。这种操作的代价是很高的，因此在实际使用时，我们应该尽量避免数组容量的扩张。当我们可预知要保存的元素的多少时，要在构造ArrayList实例时，就指定其容量，以避免数组扩容的发生。或者根据实际需求，通过调用ensureCapacity方法来手动增加ArrayList实例的容量。<br>&emsp;&emsp; ArrayList还给我们提供了将底层数组的容量调整为当前列表保存的实际元素的大小的功能。它可以通过trimToSize方法来实现。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void trimToSize() &#123;  </span><br><span class="line">    modCount++;  </span><br><span class="line">    int oldCapacity = elementData.length;  </span><br><span class="line">    if (size &lt; oldCapacity) &#123;  </span><br><span class="line">        elementData = Arrays.copyOf(elementData, size);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="7-Fail-Fast机制："><a href="#7-Fail-Fast机制：" class="headerlink" title="7) Fail-Fast机制："></a>7) Fail-Fast机制：</h4><p>&emsp;&emsp;ArrayList也采用了快速失败的机制，通过记录modCount参数来实现。在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。</p>
<p>具体介绍请参考我之前的文章深入Java集合学习系列：HashMap的实现原理 中的Fail-Fast机制。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://weiyuanbiao.cn/java/jvm/JVM内存区域详解（Eden Space、Survivor Space、Old Gen、Code Cache和Perm Gen）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sherwin Wei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序员Sherwin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/java/jvm/JVM内存区域详解（Eden Space、Survivor Space、Old Gen、Code Cache和Perm Gen）/" class="post-title-link" itemprop="url">JVM内存区域详解（Eden Space、Survivor Space、Old Gen、Code Cache和Perm Gen）</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-04-18 10:36:25" itemprop="dateCreated datePublished" datetime="2018-04-18T10:36:25+08:00">2018-04-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-01-23 17:11:07" itemprop="dateModified" datetime="2019-01-23T17:11:07+08:00">2019-01-23</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="JVM区域总体分两类，heap区和非heap区。"><a href="#JVM区域总体分两类，heap区和非heap区。" class="headerlink" title="JVM区域总体分两类，heap区和非heap区。"></a>JVM区域总体分两类，heap区和非heap区。</h3><ul>
<li><p>heap区又分为： </p>
<ul>
<li>Eden Space（伊甸园）、 </li>
<li>Survivor Space(幸存者区)、 </li>
<li>Old Gen（老年代）。</li>
</ul>
</li>
<li><p>非heap区又分： </p>
<ul>
<li>Code Cache(代码缓存区)； </li>
<li>Perm Gen（永久代）； </li>
<li>Jvm Stack(java虚拟机栈)； </li>
<li>Local Method Statck(本地方法栈)；</li>
</ul>
</li>
</ul>
<p>下面我们对每一个内存区域做详细介绍。 </p>
<h3 id="堆区-heap区"><a href="#堆区-heap区" class="headerlink" title="堆区(heap区)"></a>堆区(heap区)</h3><p>Eden Space字面意思是伊甸园，对象被创建的时候首先放到这个区域，进行垃圾回收后，不能被回收的对象被放入到空的survivor区域。</p>
<p>Survivor Space幸存者区，用于保存在eden space内存区域中经过垃圾回收后没有被回收的对象。Survivor有两个，分别为To Survivor、 From Survivor，这个两个区域的空间大小是一样的。执行垃圾回收的时候Eden区域不能被回收的对象被放入到空的survivor（也就是To Survivor，同时Eden区域的内存会在垃圾回收的过程中全部释放），另一个survivor（即From Survivor）里不能被回收的对象也会被放入这个survivor（即To Survivor），然后To Survivor 和 From Survivor的标记会互换，始终保证一个survivor是空的。</p>
<p><img src="http://p5zbw6dku.bkt.clouddn.com/18-4-18/24402118.jpg" alt="image"></p>
<p>这里写图片描述<br>Eden Space和Survivor Space都属于新生代，新生代中执行的垃圾回收被称之为Minor GC（因为是对新生代进行垃圾回收，所以又被称为Young GC），每一次Young GC后留下来的对象age加1。</p>
<ul>
<li>注：GC为Garbage Collection，垃圾回收。</li>
</ul>
<p>Old Gen老年代，用于存放新生代中经过多次垃圾回收仍然存活的对象，也有可能是新生代分配不了内存的大对象会直接进入老年代。经过多次垃圾回收都没有被回收的对象，这些对象的年代已经足够old了，就会放入到老年代。</p>
<p>当老年代被放满的之后，虚拟机会进行垃圾回收，称之为Major GC。由于Major GC除并发GC外均需对整个堆进行扫描和回收，因此又称为Full GC。</p>
<p>heap区即堆内存，整个堆大小=年轻代大小 + 老年代大小。堆内存默认为物理内存的1/64(&lt;1GB)；默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制，可以通过MinHeapFreeRatio参数进行调整；默认空余堆内存大于70%时，JVM会减少堆直到-Xms的最小限制，可以通过MaxHeapFreeRatio参数进行调整。</p>
<h3 id="非堆内存（非heap区）"><a href="#非堆内存（非heap区）" class="headerlink" title="非堆内存（非heap区）"></a>非堆内存（非heap区）</h3><p>Code Cache代码缓存区，它主要用于存放JIT所编译的代码。CodeCache代码缓冲区的大小在client模式下默认最大是32m，在server模式下默认是48m，这个值也是可以设置的，它所对应的JVM参数为ReservedCodeCacheSize 和 InitialCodeCacheSize，可以通过如下的方式来为Java程序设置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:ReservedCodeCacheSize=128m</span><br></pre></td></tr></table></figure></p>
<p>CodeCache缓存区是可能被充满的，当CodeCache满时，后台会收到CodeCache is full的警告信息，如下所示：<br>“CompilerThread0” java.lang.OutOfMemoryError: requested 2854248 bytes for Chunk::new. Out of swap space?</p>
<ul>
<li>注：JIT编译器是在程序运行期间，将Java字节码编译成平台相关的二进制代码。正因为此编译行为发生在程序运行期间，所以该编译器被称为Just-In-Time编译器。</li>
</ul>
<p><strong>Perm Gen</strong>全称是Permanent Generation space，是指内存的永久保存区域，因而称之为永久代。这个内存区域用于存放Class和Meta的信息，Class在被 Load的时候被放入这个区域。因为Perm里存储的东西永远不会被JVM垃圾回收的，所以如果你的应用程序LOAD很多CLASS的话，就很可能出现PermGen space错误。默认大小为物理内存的1/64。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://weiyuanbiao.cn/生活/程序员最艰巨的十大任务/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sherwin Wei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序员Sherwin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/生活/程序员最艰巨的十大任务/" class="post-title-link" itemprop="url">程序员最艰巨的十大任务</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-04-11 11:12:41" itemprop="dateCreated datePublished" datetime="2018-04-11T11:12:41+08:00">2018-04-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-01-23 17:11:07" itemprop="dateModified" datetime="2019-01-23T17:11:07+08:00">2019-01-23</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/生活/" itemprop="url" rel="index"><span itemprop="name">生活</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>程序员最艰巨的十大任务</p>
<p>程序员最艰巨的任务跟编写代码没有多少关系。编码是逻辑思路的一种实践，这跟程序员日常工作中的其它任务比起来相对简单。如果你认为自己还是一个水平一般的程序员，在你真正的能进入到高手行列前，请确保你已经克服了下列晋级的障碍。</p>
<ul>
<li>解释你在干什么</li>
</ul>
<p>解释软件开发过程是一个很困难的事情。那些非程序员职业的人也许知道很多关于编程的事情，但很显然，他们不会编程。对于他们来说，我们的生活就是在一间黑暗的屋子里趴在键盘前消耗着咖啡。</p>
<p>你会在你的朋友、家人和同事中遇到这样的人，他会认为编码不是一个正确的职业。</p>
<ul>
<li>形象的说出软件解决方案</li>
</ul>
<p>根据一些简短的需求——通常是一知半解的，你需要设计出数据结构，软件架构，代码算法，通信协议，以及其它所有针对商业问题的解决方案各种组成部分。然后你需要用一种外行人听的懂的术语将它们表达出来，并需要在规定的时间里提交给客户。</p>
<p>很少有程序员能做好这些。</p>
<ul>
<li>评估工期</li>
</ul>
<p>这是程序员痛苦的根源。在开发任务没有完成之前，你是绝对没有可能确定完成这个任务需要的时间。也许程序跟以前写的很相似，但环境变了，问题变了，限制条件变了。</p>
<p>经验会提供一定的判断力，但大部分的程序员都习惯于低估问题难度。这其中的原因是他们只考虑编码方面的因素，而忽略了这个任务清单上的其它事务。</p>
<ul>
<li>维护他人的代码</li>
</ul>
<p>针对一个问题可能会有一万种解决方案，一万种写法。接手别人写的代码，意味着你要花无数的时间在成千上万的代码行里探索，理解当初作者的思路。而且，如果是一个不相信注释和文档的程序员留下的半个项目，麻烦就更大了。</p>
<ul>
<li>软件边界的模糊蔓延和让人吐血的奇怪功能需求</li>
</ul>
<p>虽 然敏捷开发方法给软件范围的膨胀提供了一定的预备空间，但这并没有起到任何的作用——尤其是当你遇到一些由一时兴起的怪念头产生的功能需求。你知道这样做 必定会失败。你的团队知道这样做必定会失败。但客户觉得很好，而当失败不可避免的出现时，全是你的错，因为是你没有理解他们的真实意图。</p>
<ul>
<li>在缺少优化和过度优化之间找到平衡点</li>
</ul>
<p>复杂的软件永远不会做到完美；总会有一些更好的方案。你完全可以没完没了的优化下去，这就是为什么软件项目从来都没有提前完工的。</p>
<p>而另一面，“这样就行了——我以后会优化它的”这种心态也是常见的。代码今天好用，但你知道明天可能会出现麻烦或不能用。当然了，你是不需要去修改它的，它将会留给下一个倒霉蛋程序员。</p>
<ul>
<li>测试你的代码</li>
</ul>
<p>单元测试你也写了，软件也提交了测试组，但bug依旧存在…</p>
<p>软件是复杂的，可能包含成千上万行代码。系统中可能存在百万的各种交互和逻辑路径；你不可能完全测试它们。<br>类似的，软件会在不同的条件下跟不同的平台上的不同的软件交互。你不可能所有的都测到。<br>写出好的单元测试是一种枯燥且辛苦的工作。理想情况下，测试应该在着手开发前就已经写好——但你如何向客户解释为什么四个星期过去了仍然没有可用的软件？<br>单元测试并不能覆盖每个问题点。在理想的世界里，应该有一个独立的团队来写测试并积极的去发现问题。不幸的是，对大多数项目来说，这样成本太高，时间不够，于是用开发团队来写测试程序。而开发团队潜意识的会避免很多极端的边界情况。<br>程序员喜欢用符合逻辑的方式处理所有问题。但用户很少是这样的。他们会发现你永远意想不到的问题。</p>
<ul>
<li>写软件文档</li>
</ul>
<p>给代码写文档是一项费力耗时的工作。很少有程序员擅长这个、喜欢这个的，并且很少有程序员会花时间去读它们。</p>
<ul>
<li>处理IT问题</li>
</ul>
<p>你每天都在研究技术。你也许是一个HTML或PHP程序员，但你很可能会遇到一些例如硬盘损坏、驱动冲突或软件崩溃的问题。解决这些事情不是你的主要责任，但是，除非你解决了这些问题，否者你将无法继续你的开发工作。</p>
<p>不幸的是，对于IT圈外的人来说，程序员应该是软硬件都精通的人。当他们遇到了问题，他们自己不花时间就解决，直接会找你。不论是遇到什么问题：你是用计算机的，你一定知道如何将预算表导入Sage，如何配置Oracle，或为何在他们的黑莓手机上发不出邮件。</p>
<p>当然了，这些打搅绝对不能成为你完不成工作的理由，也没有报酬，不是吗？</p>
<ul>
<li>处理人的问题</li>
</ul>
<p>上面的这些难题都可以总结为“人的问题”。很少有外行人会去建议一个飞行员如何开飞机或建议一个电器工程师如何布线。但很多人却会兴致勃勃的勇敢的建议如何开发软件。</p>
<p>我相信对于这些人没有什么好办法。你需要接受这样的事实：这世界上有一半的智力是低于平均水平的！</p>
<p>[英文原文：The Ten Toughest Tasks in Development ]</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Sherwin Wei</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">36</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">11</span>
                    <span class="site-state-item-name">分类</span>
                  
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">13</span>
                    <span class="site-state-item-name">标签</span>
                  
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/yourname" title="GitHub &rarr; https://github.com/yourname" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://weibo.com/yourname" title="Weibo &rarr; https://weibo.com/yourname" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">  <a href="http://www.beian.miit.gov.cn" rel="noopener" target="_blank">粤ICP备15018188号-1 </a>&copy; 2018 – <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sherwin Wei</span>

  

  
</div>









        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    
      <div>
        
  <script>
    window._bd_share_config = {
      "common": {
        "bdText": "",
        "bdMini": "1",
        "bdMiniList": false,
        "bdPic": ""
      },
      "image": {
        "viewList": ["tsina", "douban", "sqq", "qzone", "weixin", "twi", "fbook"],
        "viewText": "分享到：",
        "viewSize": "16"
      },
      "slide": {
        "bdImg": "5",
        "bdPos": "left",
        "bdTop": "100"
      }
    }
  </script>

<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

      </div>
    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.2"></script>

  <script src="/js/motion.js?v=7.1.2"></script>



  
  


  <script src="/js/affix.js?v=7.1.2"></script>

  <script src="/js/schemes/pisces.js?v=7.1.2"></script>




  

  


  <script src="/js/next-boot.js?v=7.1.2"></script>


  

  

  

  



  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

  

  

  

  

  

  
<script>
  $('.highlight').not('.gist .highlight').each(function(i, e) {
    var $wrap = $('<div>').addClass('highlight-wrap');
    $(e).after($wrap);
    $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
      var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
        return $(e).text();
      }).toArray().join('\n');
      var ta = document.createElement('textarea');
      var yPosition = window.pageYOffset || document.documentElement.scrollTop;
      ta.style.top = yPosition + 'px'; // Prevent page scroll
      ta.style.position = 'absolute';
      ta.style.opacity = '0';
      ta.readOnly = true;
      ta.value = code;
      document.body.appendChild(ta);
      const selection = document.getSelection();
      const selected = selection.rangeCount > 0 ? selection.getRangeAt(0) : false;
      ta.select();
      ta.setSelectionRange(0, code.length);
      ta.readOnly = false;
      var result = document.execCommand('copy');
      
        if (result) $(this).text('复制成功');
        else $(this).text('复制失败');
      
      ta.blur(); // For iOS
      $(this).blur();
      if (selected) {
        selection.removeAllRanges();
        selection.addRange(selected);
      }
    })).on('mouseleave', function(e) {
      var $b = $(this).find('.copy-btn');
      setTimeout(function() {
        $b.text('复制');
      }, 300);
    }).append(e);
  })
</script>


  

  

</body>
</html>
