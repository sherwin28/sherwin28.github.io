<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[12.字节码的初步认识,来自i=i++,i=++i原理分析]]></title>
    <url>%2Fjava%2Fjava%20%E9%AB%98%E7%BA%A7%E7%B3%BB%E5%88%97%2F12.%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86%2F</url>
    <content type="text"><![CDATA[首先来代码:1234567public class TestPlusPlus &#123; public static void main(String[] args) &#123; int i = 0; i++; System.err.println(i); &#125;&#125; 然后执行 javap -c TestPlusPlus1234567891011121314151617public class TestPlusPlus &#123; public TestPlusPlus(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return public static void main(java.lang.String[]); Code: 0: iconst_0 //把int型常量0push到栈中,即当前栈顶的值为1 1: istore_1 //pop栈顶的1给变量i。赋值操作(i=0) 2: iinc 1, 1 //自增指令。变量i的值加0,执行完成后,i的值为1 5: getstatic #2 // Field java/lang/System.err:Ljava/io/PrintStream; 8: iload_1 9: invokevirtual #3 // Method java/io/PrintStream.println:(I)V 12: return&#125; 然后改造下代码:1234567public class TestPlusPlus &#123; public static void main(String[] args) &#123; int i = 0; i = i++; System.err.println(i); &#125;&#125; 执行 javap -c TestPlusPlus12345678910111213141516171819public class TestPlusPlus &#123; public TestPlusPlus(); Code: 0: aload_0 //将指定的引用类型本地变量 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return public static void main(java.lang.String[]); Code: 0: iconst_0 1: istore_1 2: iload_1 //push局部变量i的值0入栈，即当前栈顶的值为0 3: iinc 1, 1 //自增指令。变量i的值加1,执行完成后,i的值为1 6: istore_1 //pop栈顶的0赋给变量i。即变量i存放的值1被栈顶的元素覆盖，变为0 7: getstatic #2 // Field java/lang/System.err:Ljava/io/PrintStream; 10: iload_1 11: invokevirtual #3 // Method java/io/PrintStream.println:(I)V 14: return&#125; 再次改变代码:1234567public class TestPlusPlus &#123; public static void main(String[] args) &#123; int i = 0; i = ++i; System.err.println(i); &#125;&#125; 执行javap -c TestPlusPlus12345678910111213141516171819public class TestPlusPlus &#123; public TestPlusPlus(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return public static void main(java.lang.String[]); Code: 0: iconst_0 1: istore_1 2: iinc 1, 1 //自增指令。变量i的值加1,执行完成后,i的值为1 5: iload_1 //push局部变量i的值1入栈，即当前栈顶的值为1 6: istore_1 //pop栈顶的1赋给变量i. 7: getstatic #2 // Field java/lang/System.err:Ljava/io/PrintStream; 10: iload_1 11: invokevirtual #3 // Method java/io/PrintStream.println:(I)V 14: return&#125; 主要关注iinc 1, 1和 iload_1和istore_1.]]></content>
      <categories>
        <category>java高级系列</category>
      </categories>
      <tags>
        <tag>java高级系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习能力]]></title>
    <url>%2F%E7%94%9F%E6%B4%BB%2F%E5%AD%A6%E4%B9%A0%E8%83%BD%E5%8A%9B%2F</url>
    <content type="text"><![CDATA[学习能力脚踏实地，循序渐进比如你想要做Web开发，那么可能就需要明确阶段性的目标，如先从前端或是后端的某个点着手，一点点拓展到其他的技术栈。 而一上手就要做高大上，就要采用“MEAN”（MongoDB+Express+Angular.js+Nginx）技术栈之类的，是不现实的。 在这几年的招聘过程中，个人感觉现在的前端圈子非常浮躁，很多毕业没两年的年轻人都会打上这样的标签：“精通jQuery”、“精通React”、“熟练使用xxx进行HTML5移动开发”之类的，笔试或者提问一些CSS基础、JS基础、简单算法都答不上来。会这些上层应用框架再多，也只是做一些代码的搬运工作，不太需要智商投入的事情，何来的底气要那么高的待遇？ 无知要比知识更容易产生自信。—— 查尔斯·达尔文（达克效应） 对于新人来讲，基础很重要，不仅要只其然，还要知其所以然。 比如，使用jQuery可以快速上手前端开发，只需要看过几个示例，对照着文档写代码就行了，非常方便。但是jQuery有自身性能和兼容性的局限，所以如果不懂原生js的话，只能机械重复去做一些简单的上层应用，很难再有突破。 比如，想要采用一种新的框架，如Angular.js，那么也是需要了解一些ES 6特性、TypeScript之类的前置知识基础，才能够更快地上手。 改善学习习惯，提高学习效率每个人都有自己吸收知识的方式，有的同学喜欢看行业相关的新闻、博客，有的同学喜欢看各种视频、讲座，也有喜欢看书的。 无论是音频还是视频，所能传递的知识，都没有书本多。看书、看相关的文字资料，是吸收知识最快最有效的方式，虽然也是最无聊、最枯燥的方式。 虽然经常会听到“人丑就要多读书”、“人穷就要多读书”的黑梗，读书的必要性还是很大的。 一日不读书，无人看得出；一周不读书，开始会爆粗；一月不读书，智商输给猪。 知识在大脑中的存留率是不高的，很容易就会忘记，所以经常复习会加深记忆。 最好能养成记录的习惯，学习笔记、心得、踩过的坑都可以记录下来，以防日后想用的时候又忘记了，还得重新看一遍。 学以致用学以致用也是一种学习的能力。 如果学到的知识不能转变成价值的传递，那么学了又有什么意义？ 勤能补拙是良训，一分辛苦一分才对于没有天赋，基础也很薄弱，但对这一领域又非常有兴趣的同学，你们要加倍努力。世上无难事，只怕有心人，不要轻言放弃。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活,成功</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[11.mybatis原理分析]]></title>
    <url>%2Fjava%2Fjava%20%E9%AB%98%E7%BA%A7%E7%B3%BB%E5%88%97%2F11.mybatis%20%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[mybatis运行流程sql封装流程结果集绑定方式注意问题]]></content>
      <categories>
        <category>java高级系列</category>
      </categories>
      <tags>
        <tag>java高级系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10.二叉树.B+树.红黑树等各种树]]></title>
    <url>%2Fjava%2Fjava%20%E9%AB%98%E7%BA%A7%E7%B3%BB%E5%88%97%2F10.%E4%BA%8C%E5%8F%89%E6%A0%91.B%2B%E6%A0%91.%E7%BA%A2%E9%BB%91%E6%A0%91%E7%AD%89%E5%90%84%E7%A7%8D%E6%A0%91%2F</url>
    <content type="text"><![CDATA[树的简介二叉树B树B+树红黑树]]></content>
      <categories>
        <category>java高级系列</category>
      </categories>
      <tags>
        <tag>java高级系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 之 JUC]]></title>
    <url>%2Fjava%2Fjuc%2Fjava%20juc%2F</url>
    <content type="text"><![CDATA[Java 之 JUC1. JUC 简介在 Java 5.0 提供了 java.util.concurrent(简称JUC)包,在此包中增加了在并发编程中很常用的工具类,用于定义类似于线程的自定义子系统,包括线程池,异步 IO 和轻量级任务框架;还提供了设计用于多线程上下文中的 Collection 实现等; 2. volatile 关键字 volatile 关键字: 当多个线程进行操作共享数据时,可以保证内存中的数据是可见的;相较于 synchronized 是一种较为轻量级的同步策略; volatile 不具备”互斥性”; volatile 不能保证变量的”原子性”;12345678910111213141516171819202122232425262728293031323334353637383940// 使用 volatile 之前public class TestVolatile&#123; public static void main(String[] args)&#123; ThreadDemo td = new ThreadDemo(); new Thread(td).start(); while(true)&#123; if(td.isFlag())&#123; System.out.println("########"); break; &#125; &#125; &#125;&#125;class ThreadDemo implements Runnable&#123; private boolean flag = false; public void run()&#123; try&#123; // 该线程 sleep(200), 导致了程序无法执行成功 Thread.sleep(200); &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; flag = true; Sytem.out.println("flag="+isFlag()); &#125; public boolean isFlag()&#123; return flag; &#125; public void setFlag(boolean flag)&#123; this.flag = flag; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142// 解决问题方式一: 同步锁// 但是,效率太低public class TestVolatile&#123; public static void main(String[] args)&#123; ThreadDemo td = new ThreadDemo(); new Thread(td).start(); while(true)&#123; // 使用同步锁 synchronized(td)&#123; if(td.isFlag())&#123; System.out.println("########"); break; &#125; &#125; &#125; &#125;&#125;// 解决方式二: 使用 volatile 关键字public class TestVolatile&#123; public static void main(String[] args)&#123; ThreadDemo td = new ThreadDemo(); new Thread(td).start(); while(true)&#123; if(td.isFlag())&#123; System.out.println("########"); break; &#125; &#125; &#125;&#125;class ThreadDemo implements Runnable&#123; private volatile boolean flag = false; 同上(略)&#125; 3. i++ 的原子性问题i++的操作实际上分为三个步骤: “读-改-写”; 原子性: 就是”i++”的”读-改-写”是不可分割的三个步骤; 原子变量: JDK1.5 以后, java.util.concurrent.atomic包下,提供了常用的原子变量; 原子变量中的值,使用 volatile 修饰,保证了内存可见性;CAS(Compare-And-Swap) 算法保证数据的原子性; 12int i = 10;i = i++; // 此时, i=10 执行步骤:int temp = i;i = i + 1;i = temp; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 测试类public class TestAtomicDemo&#123; public static void main(String[] args)&#123; AtomicDemo ad = new AtomicDemo(); for(int i=0; i &lt; 10; i++)&#123; new Thread(ad).start(); &#125; &#125;&#125;class AtomicDemo implements Runnable&#123; private int serialNumber = 0; public void run()&#123; try&#123; Thread.sleep(200); &#125;catch(InterruptedException e)&#123; &#125; System.out.println(Thread.currentThread().getName() + ":" + getSerialNumber()); &#125; public int getSerialNumber()&#123; return serialNumber++; &#125;&#125;// 改进: 使用原子变量class AtomicDemo implements Runnable&#123; private AtomicInteger serialNumber = new AtomicInteger(); public void run()&#123; try&#123; Thread.sleep(200); &#125;catch(InterruptedException e)&#123; &#125; System.out.println(Thread.currentThread().getName()+":"+getSerialNumber()); &#125; public int getSerialNumber()&#123; // 自增运算 return serialNumber.getAndIncrement(); &#125;&#125; 3.1 CAS 算法CAS(Compare-And-Swap) 算法是硬件对于并发的支持,针对多处理器操作而设计的处理器中的一种特殊指令,用于管理对共享数据的并发访问; CAS 是一种无锁的非阻塞算法的实现; CAS 包含了三个操作数: 需要读写的内存值: V 进行比较的预估值: A 拟写入的更新值: B当且仅当 V == A 时, V = B, 否则,将不做任何操作; 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 模拟CAS 算法class CompareAndSwap&#123; private int value; // 获取内存值 public synchronized int get()&#123; return value; &#125; // 无论更新成功与否,都返回修改之前的内存值 public synchronized int compareAndSwap(int expectedValue, int newValue)&#123; // 获取旧值 int oldValue = value; if(oldValue == expectedValue)&#123; this.value = newValue; &#125; // 返回修改之前的值 return oldValue; &#125; // 判断是否设置成功 public synchronized boolean compareAndSet(int expectedValue, int newValue)&#123; return expectedValue == compareAndSwap(expectedValue, newValue); &#125;&#125;public class TestCompareAndSwap&#123; public static void main(String[] args)&#123; final CopareAndSwap cas = new CompareAndSwap(); for(int i=0; i&lt;10; i++)&#123; // 创建10个线程,模拟多线程环境 new Thead(new Runnable()&#123; public void run()&#123; int expectedValue = cas.get(); boolean b = cas.compareAndSet(expectedValue, (int)(Math.random()*100)); System.out.println(b); &#125; &#125;).start(); &#125; &#125;&#125; 4. 并发容器类Java 5.0 在 java.util.concurrent 包中提供了多种并发容器类来改进同步容器的性能; 4.1 ConcurrentHashMapConcurrentHashMap 同步容器类是 Java5 增加的一个线程安全的哈希表;介于 HashMap 与 Hashtable 之间;内部采用”锁分段”机制替代Hashtable的独占锁,进而提高性能;此包还提供了设计用于多线程上下文中的Collection实现: ConcurrentHashMap,ConcurrentSkipListMapConcurrentSkipListSet, CopyOnWriteArrayList 和 CopyOnWriteArraySet;当期望许多线程访问一个给定collection时,ConcurrentHashMap通常优于同步的HashMap;ConcurrentSkipListMap通常优于同步的TreeMap;当期望的读数和遍历远远大于列表的更新数时, CopyOnWriteArrayList优于同步的ArrayList; 4.2 CountDownLatch(闭锁)CountDownLatch是一个同步辅助类,在完成一组正在其他线程中执行的操作之前,它允许一个或多个线程一直等待;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 测试类: 计算多线程的执行时间public class TestCountDownLatch&#123; public static void main(String[] args)&#123; final CountDownLatch latch = new CountDownLatch(10); LatchDemo ld = new LatchDemo(latch); long start = System.currentTimeMillis(); // 创建10个线程 for(int i=0; i&lt;10; i++)&#123; new Thread(ld).start(); &#125; try&#123; latch.await(); &#125;catch(InterruptedException e)&#123; &#125; long end = System.currentTimeMillis(); System.out.println("耗费时间为:"+(end - start)); &#125;&#125;class LatchDemo implements Runnable&#123; private CountDownLatch latch; // 有参构造器 public LatchDemo(CountDownLatch latch)&#123; this.latch = latch; &#125; public void run()&#123; synchronized(this)&#123; try&#123; // 打印50000以内的偶数 for(int i=0; i&lt;50000; i++)&#123; if(i % 2 == 0)&#123; System.out.println(i); &#125; &#125; &#125;finally&#123; // 线程数量递减 latch.countDown(); &#125; &#125; &#125;&#125; 5. 创建执行线程的方式三相较于实现 Runnable 接口的方式,实现 Callable 接口类中的方法可以有返回值,并且可以抛出异常;1234567891011121314151617181920212223242526272829303132333435363738// 测试类public class TestCallable&#123; public static void main(String[] args)&#123; ThreadDemo td = new ThreadDemo(); // 执行 Callable 方式,需要 FutureTask 实现类的支持 // FutureTask 实现类用于接收运算结果, FutureTask 是 Future 接口的实现类 FutureTask&lt;Integer&gt; result = new FutureTask&lt;&gt;(td); new Thread(result).start(); // 接收线程运算后的结果 try&#123; // 只有当 Thread 线程执行完成后,才会打印结果; // 因此, FutureTask 也可用于闭锁 Integer sum = result.get(); System.out.println(sum); &#125;catch(InterruptedException | ExecutionException e)&#123; e.printStackTrace(); &#125; &#125;&#125;class ThreadDemo implements Callable&lt;Integer&gt;&#123; // 需要实现的方法 public Integer call() throws Exception&#123; // 计算 0~100 的和 int sum = 0; for(int i=0; i&lt;=100; i++)&#123; sum += i; &#125; return sum; &#125;&#125; 6. 同步锁(Lock)参考 “java 多线程间通信” 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 测试类: 以卖票为例// 使用 lock 之前public class TestLock&#123; public static void main(String[] args)&#123; Ticket ticket = new Ticket(); new Thread(ticket,"1号窗口").start(); new Thread(ticket,"2号窗口").start(); new Thread(ticket,"3号窗口").start(); &#125;&#125;class Ticket implements Runnable&#123; private int tick = 100; public void run()&#123; while(true)&#123; if(tick &gt; 0)&#123; try&#123; Thread.sleep(200); &#125;catch(InterruptedException e)&#123; &#125; System.out.println(Thread.currentThread().getName()+"完成售票,余票为: "+ --tick); &#125; &#125; &#125;&#125;// 使用 Lockclass Ticket implements Runnable&#123; private int tick = 100; private Lock lock = new ReentrantLock(); public void run()&#123; while(true)&#123; // 上锁 lock.lock(); try&#123; if(tick &gt; 0)&#123; try&#123; Thread.sleep(200); &#125;catch(InterruptedException e)&#123; &#125; System.out.println(Thread.currentThread().getName()+"完成售票,余票为: "+ --tick); &#125; &#125;finally&#123; // 释放锁 lock.unlock(); &#125; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131// 练习: 程序按序交替// 编写一个程序,开启3个线程,这三个线程的 ID 分别为 A, B, C, 每个线程将自己的 ID 在屏幕上打印10遍,// 要求输出的结果必须按顺序显示:// 如: ABCABCABC... 依次递归public class TestABCAlternate&#123; public static void main(String[] args)&#123; AlternateDemo ad = new AlternateDemo(); new Thread(new Runnable()&#123; public void run()&#123; for(int i=1; i&lt;20; i++)&#123; ad.loopA(i); &#125; &#125; &#125;,"A").start(); new Thread(new Runnable()&#123; public void run()&#123; for(int i=1; i&lt;20; i++)&#123; ad.loopB(i); &#125; &#125; &#125;,"B").start(); new Thread(new Runnable()&#123; public void run()&#123; for(int i=1; i&lt;20; i++)&#123; ad.loopC(i); System.out.println("--------------------"); &#125; &#125; &#125;,"C").start(); &#125;&#125;class AlternateDemo&#123; private int number = 1; // 当前正在执行线程的标记 private Lock lock = new ReentrantLock(); private Condition condition1 = lock.newCondition(); private Condition condition2 = lock.newCondition(); private Condition condition3 = lock.newCondition(); // totalLoop 表示循环第几轮 // 线程A public void loopA(int totalLoop)&#123; // 上锁 lock.lock(); try&#123; // 1. 判断 if(number != 1)&#123; condition1.await(); &#125; // 2. 打印 for(int i=1; i &lt;= 5; i++)&#123; System.out.println(Thread.currentThread().getName()+"\t"+i+"\t"+totalLoop); &#125; // 3. 唤醒线程B number = 2; condition2.signal(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; // 释放锁 lock.unlock(); &#125; &#125; // 线程B public void loopB(int totalLoop)&#123; // 上锁 lock.lock(); try&#123; // 1. 判断 if(number != 2)&#123; condition2.await(); &#125; // 2. 打印 for(int i=1; i &lt;= 15; i++)&#123; System.out.println(Thread.currentThread().getName()+"\t"+i+"\t"+totalLoop); &#125; // 3. 唤醒线程C number = 3; condition3.signal(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; // 释放锁 lock.unlock(); &#125; &#125; // 线程C public void loopC(int totalLoop)&#123; // 上锁 lock.lock(); try&#123; // 1. 判断 if(number != 3)&#123; condition3.await(); &#125; // 2. 打印 for(int i=1; i &lt;= 20; i++)&#123; System.out.println(Thread.currentThread().getName()+"\t"+i+"\t"+totalLoop); &#125; // 3. 唤醒线程A number = 1; condition1.signal(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; // 释放锁 lock.unlock(); &#125; &#125;&#125; 7. ReadWriteLock(读写锁)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 测试类public class TestReadWriteLock&#123; public static void main(String[] args)&#123; ReadWriteLockDemo rw = new ReadWriteLockDemo(); // 一个线程进行写 new Thread(new Runnable()&#123; public void run()&#123; rw.set((int)(Math.random()*100)); &#125; &#125;,"Write:").start(); // 100个线程进行读操作 for(int i=0; i&lt;100; i++)&#123; new Thread(new Runnable()&#123; public void run()&#123; rw.get(); &#125; &#125;,"Read:").start(); &#125; &#125;&#125;class ReadWriteLockDemo&#123; private int number = 0; private ReadWriteLock lock = new ReentrantReadWriteLock(); // 读 public void get()&#123; lock.readLock().lock(); // 上锁 try&#123; System.out.println(Thread.currentThread().getName()+":"+number); &#125;finally&#123; lock.readLock().unlock(); // 释放锁 &#125; &#125; // 写 public void set(int number)&#123; lock.writeLock().lock(); try&#123; System.out.println(Thread.currentThread().getName()); this.number = number; &#125;finally&#123; lock.writeLock().unlock(); &#125; &#125;&#125; 8. 线程八锁123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 测试类public class Test&#123; public static void main(String[] args)&#123; Demo demo = new Demo(); Demo demo2 = new Demo(); new Thread(new Runnable()&#123; public void run()&#123; demo.getOne(); &#125; &#125;).start(); new Thread(new Runnable()&#123; public void run()&#123; // demo2.getTwo(); demo.getTwo(); &#125; &#125;).start(); &#125;&#125;class Demo&#123; public synchronized void getOne()&#123; try&#123; Thread.sleep(3000); &#125;catch(InterruptedException e)&#123; &#125; System.out.println("one"); &#125; public synchronized void getTwo()&#123; System.out.println("two"); &#125;&#125;/* * 1. 两个普通同步方法,两个线程,标准打印, 打印输出: one two * 2. 新增 Thread.sleep() 给 getOne(), 打印输出: one two * 3. 新增普通方法 getThree(), 打印输出: three one two * 4. 两个普通同步方法,两个Demo对象, 两个线程,打印输出: two one * 5. 修改 getOne() 为静态同步方法, 一个Demo对象, 打印输出: two one * 6. 修改两个方法都为静态同步方法, 一个 Demo 对象, 打印输出: one two * 7. 修改 getone() 为静态同步方法, 两个 Demo 对象, 打印输出: two one * 8. 两个均为静态同步方法,两个 Demo 对象,打印输出: one two */ // 总结: // 1. 非静态方法的锁默认为 this, 静态方法的锁为 "对应的Class实例"; // 2. 在某一个时刻内,只能有一个线程持有锁,无论几个方法; 9. 线程池线程池提供了一个线程队列,队列中保存着所有等待状态的线程;避免了创建与销毁线程的额外开销,提高了响应速度; 线程池的体系结构 java.util.concurrent.Executor: 负责线程的使用和调度的根接口; ExecutorService: 子接口,线程池的主要接口; ThreadPoolExecutor: 线程池的实现类; ScheduledExecutorService: 子接口,负责线程的调度; ScheduledThreadPoolExecutor: 继承了线程池的实现类,实现了负责线程调度的子接口; 工具类: Executors ExecutorService newFixedThreadPool(): 创建固定大小的线程池; ExecutorService newCachedThreadPool(): 缓存线程池,线程池中线程的数量不固定,可以根据需求自动更改数量; ExecutorService newSingleThreadExecutor(): 创建单个线程池, 线程池中只有一个线程; ScheduledExecutorService newScheduledThreadPool(): 创建固定大小的线程,可以延时或定时的执行任务; 123456789101112131415161718192021222324252627282930public class TestThreadPool&#123; public static void main(String[] args)&#123; // 1. 创建线程池 ExecutorService pool = Executors.newFixedThreadPool(5); ThreadPoolDemo tpd = new ThreadPoolDemo(); // 2. 为线程池中线程分配任务 // submit(Callable&lt;T&gt; task) // submit(Runnable task) for(int i=0; i&lt;10; i++)&#123; pool.submit(tpd); &#125; // 3. 关闭线程池 pool.shutdown(); &#125;&#125;class ThreadPoolDemo implements Runnable&#123; private int i=0; public void run()&#123; while(i &lt;= 100)&#123; System.out.println(Thread.currentThread().getName()+" : "+ i++) &#125; &#125;&#125; 9.1 线程调度1234567891011121314151617181920212223242526272829public class TestScheduledThreadPool&#123; public static void main(String[] args) throws Exception&#123; // 1. 创建线程池 ScheduledExecutorService pool = Executors.newScheduledThreadPool(5); // 2. 分配任务 // pool.shedule(Callalbe&lt;T&gt; callable, long delay, TimeUnit unit(时间单位)) for(int i=0; i &lt; 10; i++)&#123; Future&lt;Integer&gt; result = pool.schedule(new Callable&lt;Integer&gt;()&#123; public Integer call() throws Exception&#123; // 产生100以内的随机数 int num = new Random().nextInt(100); System.out.println(Thread.currentThread().getName()+ ":" + num); return num; &#125; &#125;, 3, TimeUnit.SECONDS); System.out.println(result.get()); &#125; //3. 关闭线程池 pool.shutdown(); &#125;&#125; 10 Fork/Join 框架1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class TestForkJoinPool&#123; public static void main(String[] args)&#123; ForkJoinPool pool = new ForkJoinPool(); ForkJoinTask&lt;Long&gt; task = new ForkJoinSumCalculate(0L, 100000000L); Long sum = pool.invoke(task); System.out.println(sum); &#125;&#125;class ForkJoinSumCalculate extends RecursiveTask&lt;Long&gt;&#123; private static final long serialVersionUID = 24340990L; private long start; private long end; private static final long THURSHOLD = 10000L; // 拆分临界值 // 有参构造器 public ForkJoinSumCalculate(long start, long end)&#123; this.start = start; this.end = end; &#125; public Long compute()&#123; long length = end - start; if(length &lt;= THURSHOLD)&#123; long sum = 0L; for(long i = start; i&lt;=end; i++)&#123; sum += i; &#125; return sum; &#125;else&#123; long middle = (start + end ) / 2; ForkJoinSumCalculate left = new ForkJoinSumCalculate(start, middle); left.fork(); // 进行拆分,同时压入线程队列 ForkJoinSumCalculate right = new ForkJoinSumCalculate(middle + 1, end); right.fork(); // 进行拆分,同时压入线程队列 return left.join() + right.join(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阻止事件冒泡，阻止默认事件，event.stopPropagation()和event.preventDefault()，return false的区别]]></title>
    <url>%2Fweb%E5%89%8D%E7%AB%AF%2F%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%EF%BC%8C%E9%98%BB%E6%AD%A2%E9%BB%98%E8%AE%A4%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[今天来看看前端的冒泡和事件默认事件如何处理 1.event.stopPropagation()方法这是阻止事件的冒泡方法，不让事件向documen上蔓延，但是默认事件任然会执行，当你掉用这个方法的时候，如果点击一个连接，这个连接仍然会被打开， 2.event.preventDefault()方法这是阻止默认事件的方法，调用此方法是，连接不会被打开，但是会发生冒泡，冒泡会传递到上一层的父元素； 3.return false ；这个方法比较暴力，他会同事阻止事件冒泡也会阻止默认事件；写上此代码，连接不会被打开，事件也不会传递到上一层的父元素；可以理解为return false就等于同时调用了event.stopPropagation()和event.preventDefault() 4.我们来看看几组demo，使用jquery进行DOM操作这是html代码，div里面套了一个a标签，连接到百度 123&lt;div class="box1"&gt; &lt;a href="http://www.baidu.com" target="_blank"&gt;&lt;/a&gt;&lt;/div&gt; css代码，a标签占父元素的空间的1/4，背景颜色为红色；1234567891011.box1&#123; height: 200px; width: 600px; margin: 0 auto;&#125;.box1 a&#123; display: block; height: 50%; width: 50%; background：red;&#125; 下面来看js代码，第一种 1234//不阻止事件冒泡和默认事件$(".box1").click(function()&#123; console.log("1")//不阻止事件冒泡会打印1，页面跳转; &#125;); 第二种12345678//阻止冒泡$(".box1 a").click(function(event)&#123; event.stopPropagation();//不会打印1，但是页面会跳转； &#125;);$(".box1").click(function()&#123; console.log("1") &#125;); 第三种 12345678$(".box1 a").click(function(event)&#123; //阻止默认事件event.preventDefault();//页面不会跳转，但是会打印出1，&#125;)； $(".box1").click(function()&#123;console.log("1")； &#125;); 第四种 123456789$(".box1").click(function()&#123;console.log("1")&#125;); //阻止冒泡$(".box1 a").click(function(event)&#123;event.stopPropagation(); //阻止默认事件event.preventDefault() //页面不会跳转，也不会打印出1&#125;) 第五种 1234567$(".box1").click(function()&#123; console.log("1") &#125;); $(".box1 a").click(function(event)&#123; return false; //页面不会跳转，也不会打印出1，等于同时调用了event.stopPropagation()和event.preventDefault()&#125;);]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[9.Java中的锁原理、锁优化、CAS、AQS]]></title>
    <url>%2Fjava%2Fjava%20%E9%AB%98%E7%BA%A7%E7%B3%BB%E5%88%97%2F9.Java%E4%B8%AD%E7%9A%84%E9%94%81%E5%8E%9F%E7%90%86%E3%80%81%E9%94%81%E4%BC%98%E5%8C%96%E3%80%81CAS%E3%80%81AQS%2F</url>
    <content type="text"><![CDATA[一、为什么要用锁？锁-是为了解决并发操作引起的脏读、数据不一致的问题。 二、锁实现的基本原理2.1、volatileJava编程语言允许线程访问共享变量， 为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。Java语言提供了volatile，在某些情况下比锁要更加方便。volatile在多处理器开发中保证了共享变量的“ 可见性”。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。 结论：如果volatile变量修饰符使用恰当的话，它比synchronized的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。 2.2、synchronizedsynchronized通过锁机制实现同步。先来看下利用synchronized实现同步的基础：Java中的每一个对象都可以作为锁。 具体表现为以下3种形式。 对于普通同步方法，锁是当前实例对象。 对于静态同步方法，锁是当前类的Class对象。 对于同步方法块，锁是Synchonized括号里配置的对象。 当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。 2.2.1 synchronized实现原理synchronized是基于Monitor来实现同步的。Monitor从两个方面来支持线程之间的同步：互斥执行协作1、Java 使用对象锁 ( 使用 synchronized 获得对象锁 ) 保证工作在共享的数据集上的线程互斥执行。2、使用 notify/notifyAll/wait 方法来协同不同线程之间的工作。3、Class和Object都关联了一个Monitor。 Monitor 的工作机理 线程进入同步方法中。 为了继续执行临界区代码，线程必须获取 Monitor 锁。如果获取锁成功，将成为该监视者对象的拥有者。任一时刻内，监视者对象只属于一个活动线程（The Owner） 拥有监视者对象的线程可以调用 wait() 进入等待集合（Wait Set），同时释放监视锁，进入等待状态。 其他线程调用 notify() / notifyAll() 接口唤醒等待集合中的线程，这些等待的线程需要重新获取监视锁后才能执行 wait() 之后的代码。 同步方法执行完毕了，线程退出临界区，并释放监视锁。 参考文档：https://www.ibm.com/developerworks/cn/java/j-lo-synchronized 2.2.2 synchronized具体实现 1、同步代码块采用monitorenter、monitorexit指令显式的实现。 2、同步方法则使用ACC_SYNCHRONIZED标记符隐式的实现。 通过实例来看看具体实现： javap编译后的字节码如下： monitorenter 每一个对象都有一个monitor，一个monitor只能被一个线程拥有。当一个线程执行到monitorenter指令时会尝试获取相应对象的monitor，获取规则如下： 如果monitor的进入数为0，则该线程可以进入monitor，并将monitor进入数设置为1，该线程即为monitor的拥有者。 如果当前线程已经拥有该monitor，只是重新进入，则进入monitor的进入数加1，所以synchronized关键字实现的锁是可重入的锁。 如果monitor已被其他线程拥有，则当前线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor。 monitorexit 只有拥有相应对象的monitor的线程才能执行monitorexit指令。每执行一次该指令monitor进入数减1，当进入数为0时当前线程释放monitor，此时其他阻塞的线程将可以尝试获取该monitor。 2.2.3 锁存放的位置 锁标记存放在Java对象头的Mark Word中。 Java对象头长度 32位JVM Mark Word 结构 32位JVM Mark Word 状态变化 64位JVM Mark Word 结构 2.2.3 synchronized的锁优化 JavaSE1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。 在JavaSE1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。 锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。 偏向锁： 无锁竞争的情况下为了减少锁竞争的资源开销，引入偏向锁。 轻量级锁： 轻量级锁所适应的场景是线程交替执行同步块的情况。 锁粗化（Lock Coarsening）：也就是减少不必要的紧连在一起的unlock，lock操作，将多个连续的锁扩展成一个范围更大的锁。 锁消除（Lock Elimination）：锁削除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行削除。 适应性自旋（Adaptive Spinning）：自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100个循环。另一方面，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。 2.2.4 锁的优缺点对比 2.3、CAS CAS，在Java并发应用中通常指CompareAndSwap或CompareAndSet，即比较并交换。 1、CAS是一个原子操作，它比较一个内存位置的值并且只有相等时修改这个内存位置的值为新的值，保证了新的值总是基于最新的信息计算的，如果有其他线程在这期间修改了这个值则CAS失败。CAS返回是否成功或者内存位置原来的值用于判断是否CAS成功。 2、JVM中的CAS操作是利用了处理器提供的CMPXCHG指令实现的。 优点： 竞争不大的时候系统开销小。 缺点： 循环时间长开销大。 ABA问题。 只能保证一个共享变量的原子操作。 三、Java中的锁实现 3.1、队列同步器（AQS） 队列同步器AbstractQueuedSynchronizer（以下简称同步器），是用来构建锁或者其他同步组件的基础框架。 3.1.1、它使用了一个int成员变量表示同步状态。 3.1.2、通过内置的FIFO双向队列来完成获取锁线程的排队工作。 同步器包含两个节点类型的应用，一个指向头节点，一个指向尾节点，未获取到锁的线程会创建节点线程安全（compareAndSetTail）的加入队列尾部。同步队列遵循FIFO，首节点是获取同步状态成功的节点。 未获取到锁的线程将创建一个节点，设置到尾节点。如下图所示： 首节点的线程在释放锁时，将会唤醒后继节点。而后继节点将会在获取锁成功时将自己设置为首节点。如下图所示： 3.1.3、独占式/共享式锁获取 独占式：有且只有一个线程能获取到锁，如：ReentrantLock； 共享式：可以多个线程同时获取到锁，如：CountDownLatch； 独占式 每个节点自旋观察自己的前一节点是不是Header节点，如果是，就去尝试获取锁。 独占式锁获取流程： 共享式： 共享式与独占式的区别： 共享锁获取流程： 四、锁的使用用例 4.1、ConcurrentHashMap的实现原理及使用 ConcurrentHashMap类图 ConcurrentHashMap数据结构 结论：ConcurrentHashMap使用的锁分段技术。首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。]]></content>
      <categories>
        <category>java高级系列</category>
      </categories>
      <tags>
        <tag>java高级系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8.深入理解springAOP原理]]></title>
    <url>%2Fjava%2Fjava%20%E9%AB%98%E7%BA%A7%E7%B3%BB%E5%88%97%2F8.%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3springAOP%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[springAOP是什么springAOP原理动态代理原理动态代理底层实现]]></content>
      <categories>
        <category>java高级系列</category>
      </categories>
      <tags>
        <tag>java高级系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7.深入理解springIoc原理]]></title>
    <url>%2Fjava%2Fjava%20%E9%AB%98%E7%BA%A7%E7%B3%BB%E5%88%97%2F7.%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3springIoc%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[springIoc是什么springIoc原理反射原理反射底层实现]]></content>
      <categories>
        <category>java高级系列</category>
      </categories>
      <tags>
        <tag>java高级系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[6.ConcurrentHashMap原理]]></title>
    <url>%2Fjava%2Fjava%20%E9%AB%98%E7%BA%A7%E7%B3%BB%E5%88%97%2F6.ConcurrentHash%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[ConcurrentHashMap是Java并发包中提供的一个线程安全且高效的HashMap实现（若对HashMap的实现原理还不甚了解，可参考我的另一篇文章HashMap实现原理及源码分析），ConcurrentHashMap在并发编程的场景中使用频率非常之高，本文就来分析下ConcurrentHashMap的实现原理，并对其实现原理进行分析（JDK1.7). ConcurrentHashMap实现原理 众所周知，哈希表是中非常高效，复杂度为O(1)的数据结构，在Java开发中，我们最常见到最频繁使用的就是HashMap和HashTable，但是在线程竞争激烈的并发场景中使用都不够合理。 HashMap ：先说HashMap，HashMap是线程不安全的，在并发环境下，可能会形成环状链表（扩容时可能造成，具体原因自行百度google或查看源码分析），导致get操作时，cpu空转，所以，在并发环境中使用HashMap是非常危险的。 HashTable ： HashTable和HashMap的实现原理几乎一样，差别无非是1.HashTable不允许key和value为null；2.HashTable是线程安全的。但是HashTable线程安全的策略实现代价却太大了，简单粗暴，get/put所有相关操作都是synchronized的，这相当于给整个哈希表加了一把大锁，多线程访问时候，只要有一个线程访问或操作该对象，那其他线程只能阻塞，相当于将所有的操作串行化，在竞争激烈的并发场景中性能就会非常差。 HashTable性能差主要是由于所有操作需要竞争同一把锁，而如果容器中有多把锁，每一把锁锁一段数据，这样在多线程访问时不同段的数据时，就不会存在锁竞争了，这样便可以有效地提高并发效率。这就是ConcurrentHashMap所采用的”分段锁”思想。 ConcurrentHashMap源码分析 ConcurrentHashMap采用了非常精妙的”分段锁”策略，ConcurrentHashMap的主干是个Segment数组。 final Segment&lt;K,V&gt;[] segments; Segment继承了ReentrantLock，所以它就是一种可重入锁（ReentrantLock)。在ConcurrentHashMap，一个Segment就是一个子哈希表，Segment里维护了一个HashEntry数组，并发环境下，对于不同Segment的数据进行操作是不用考虑锁竞争的。（就按默认的ConcurrentLeve为16来讲，理论上就允许16个线程并发执行，有木有很酷） 所以，对于同一个Segment的操作才需考虑线程同步，不同的Segment则无需考虑。 Segment类似于HashMap，一个Segment维护着一个HashEntry数组 transient volatile HashEntry&lt;K,V&gt;[] table;HashEntry是目前我们提到的最小的逻辑处理单元了。一个ConcurrentHashMap维护一个Segment数组，一个Segment维护一个HashEntry数组。 复制代码 static final class HashEntry&lt;K,V&gt; { final int hash; final K key; volatile V value; volatile HashEntry&lt;K,V&gt; next; //其他省略}复制代码我们说Segment类似哈希表，那么一些属性就跟我们之前提到的HashMap差不离，比如负载因子loadFactor，比如阈值threshold等等，看下Segment的构造方法 Segment(float lf, int threshold, HashEntry&lt;K,V&gt;[] tab) { this.loadFactor = lf;//负载因子 this.threshold = threshold;//阈值 this.table = tab;//主干数组即HashEntry数组 }我们来看下ConcurrentHashMap的构造方法 复制代码 1 public ConcurrentHashMap(int initialCapacity, 2 float loadFactor, int concurrencyLevel) { 3 if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0) 4 throw new IllegalArgumentException(); 5 //MAX_SEGMENTS 为1&lt;&lt;16=65536，也就是最大并发数为65536 6 if (concurrencyLevel &gt; MAX_SEGMENTS) 7 concurrencyLevel = MAX_SEGMENTS; 8 //2的sshif次方等于ssize，例:ssize=16,sshift=4;ssize=32,sshif=5 9 int sshift = 0;10 //ssize 为segments数组长度，根据concurrentLevel计算得出11 int ssize = 1;12 while (ssize &lt; concurrencyLevel) {13 ++sshift;14 ssize &lt;&lt;= 1;15 }16 //segmentShift和segmentMask这两个变量在定位segment时会用到，后面会详细讲17 this.segmentShift = 32 - sshift;18 this.segmentMask = ssize - 1;19 if (initialCapacity &gt; MAXIMUM_CAPACITY)20 initialCapacity = MAXIMUM_CAPACITY;21 //计算cap的大小，即Segment中HashEntry的数组长度，cap也一定为2的n次方.22 int c = initialCapacity / ssize;23 if (c ssize &lt; initialCapacity)24 ++c;25 int cap = MIN_SEGMENT_TABLE_CAPACITY;26 while (cap &lt; c)27 cap &lt;&lt;= 1;28 //创建segments数组并初始化第一个Segment，其余的Segment延迟初始化29 Segment&lt;K,V&gt; s0 =30 new Segment&lt;K,V&gt;(loadFactor, (int)(cap loadFactor),31 (HashEntry&lt;K,V&gt;[])new HashEntry[cap]);32 Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])new Segment[ssize];33 UNSAFE.putOrderedObject(ss, SBASE, s0);34 this.segments = ss;35 }复制代码 初始化方法有三个参数，如果用户不指定则会使用默认值，initialCapacity为16，loadFactor为0.75（负载因子，扩容时需要参考），concurrentLevel为16。 从上面的代码可以看出来,Segment数组的大小ssize是由concurrentLevel来决定的，但是却不一定等于concurrentLevel，ssize一定是大于或等于concurrentLevel的最小的2的次幂。比如：默认情况下concurrentLevel是16，则ssize为16；若concurrentLevel为14，ssize为16；若concurrentLevel为17，则ssize为32。为什么Segment的数组大小一定是2的次幂？其实主要是便于通过按位与的散列算法来定位Segment的index。至于更详细的原因，有兴趣的话可以参考我的另一篇文章《HashMap实现原理及源码分析》，其中对于数组长度为什么一定要是2的次幂有较为详细的分析。 接下来，我们来看看put方法 1234567891011121314public V put(K key, V value) &#123; Segment&lt;K,V&gt; s; //concurrentHashMap不允许key/value为空 if (value == null) throw new NullPointerException(); //hash函数对key的hashCode重新散列，避免差劲的不合理的hashcode，保证散列均匀 int hash = hash(key); //返回的hash值无符号右移segmentShift位与段掩码进行位运算，定位segment int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask; if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject // nonvolatile; recheck (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) // in ensureSegment s = ensureSegment(j); return s.put(key, hash, value, false);&#125; 从源码看出，put的主要逻辑也就两步：1.定位segment并确保定位的Segment已初始化 2.调用Segment的put方法。 关于segmentShift和segmentMask segmentShift和segmentMask这两个全局变量的主要作用是用来定位Segment，int j =(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask。 segmentMask：段掩码，假如segments数组长度为16，则段掩码为16-1=15；segments长度为32，段掩码为32-1=31。这样得到的所有bit位都为1，可以更好地保证散列的均匀性 segmentShift：2的sshift次方等于ssize，segmentShift=32-sshift。若segments长度为16，segmentShift=32-4=28;若segments长度为32，segmentShift=32-5=27。而计算得出的hash值最大为32位，无符号右移segmentShift，则意味着只保留高几位（其余位是没用的），然后与段掩码segmentMask位运算来定位Segment。 get/put方法 get方法 123456789101112131415161718public V get(Object key) &#123; Segment&lt;K,V&gt; s; HashEntry&lt;K,V&gt;[] tab; int h = hash(key); long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE; //先定位Segment，再定位HashEntry if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp; (tab = s.table) != null) &#123; for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE); e != null; e = e.next) &#123; K k; if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k))) return e.value; &#125; &#125; return null; &#125; get方法无需加锁，由于其中涉及到的共享变量都使用volatile修饰，volatile可以保证内存可见性，所以不会读取到过期数据。 来看下concurrentHashMap代理到Segment上的put方法，Segment中的put方法是要加锁的。只不过是锁粒度细了而已。 复制代码final V put(K key, int hash, V value, boolean onlyIfAbsent) { HashEntry&lt;K,V&gt; node = tryLock() ? null : scanAndLockForPut(key, hash, value);//tryLock不成功时会遍历定位到的HashEnry位置的链表（遍历主要是为了使CPU缓存链表），若找不到，则创建HashEntry。tryLock一定次数后（MAX_SCAN_RETRIES变量决定），则lock。若遍历过程中，由于其他线程的操作导致链表头结点变化，则需要重新遍历。 V oldValue; try { HashEntry&lt;K,V&gt;[] tab = table; int index = (tab.length - 1) &amp; hash;//定位HashEntry，可以看到，这个hash值在定位Segment时和在Segment中定位HashEntry都会用到，只不过定位Segment时只用到高几位。 HashEntry&lt;K,V&gt; first = entryAt(tab, index); for (HashEntry&lt;K,V&gt; e = first;;) { if (e != null) { K k; if ((k = e.key) == key || (e.hash == hash &amp;&amp; key.equals(k))) { oldValue = e.value; if (!onlyIfAbsent) { e.value = value; ++modCount; } break; } e = e.next; } else { if (node != null) node.setNext(first); else node = new HashEntry&lt;K,V&gt;(hash, key, value, first); int c = count + 1; //若c超出阈值threshold，需要扩容并rehash。扩容后的容量是当前容量的2倍。这样可以最大程度避免之前散列好的entry重新散列，具体在另一篇文章中有详细分析，不赘述。扩容并rehash的这个过程是比较消耗资源的。 if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY) rehash(node); else setEntryAt(tab, index, node); ++modCount; count = c; oldValue = null; break; } } } finally { unlock(); } return oldValue; }复制代码 总结 ConcurrentHashMap作为一种线程安全且高效的哈希表的解决方案，尤其其中的”分段锁”的方案，相比HashTable的全表锁在性能上的提升非常之大。本文对ConcurrentHashMap的实现原理进行了详细分析，并解读了部分源码，希望能帮助到有需要的童鞋。]]></content>
      <categories>
        <category>java高级系列</category>
      </categories>
      <tags>
        <tag>java高级系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tcp三次握手四次挥手]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%2Fhttp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%2F</url>
    <content type="text"><![CDATA[tcp三次握手四次挥手三次握手： 第一次：客户端给服务器发请求说，我要和你建立连接 SYN=1 第二次：服务器给客户端说，我知道了，那咱两建立连接把 ACK=1 SYN=1 第三次：客户端对服务器说，好的，我知道你知道 我要和你建立连接了 ACK=1 为什么不是两次握手呢？ 第一次：客户端给服务器发请求说，我要和你建立连接 第二次：服务器给客户端说，我知道了，那咱两建立连接把 &emsp;&emsp;客户端给服务发消息，服务器由于网络阻塞或者别的原因没有收到，就不会回应，客户端一段时间没有收到服务器给他回的消息，他就会重新发送一个请求，现在在他重新发送请求后，服务器且回应了，建立连接后，且服务器收到前段时间的失效报文，服务器就建立了连接，准备接受数据。但是他已经失效了，客户端就对那个失效的消息不感冒，就不传数据，然后服务器就一直等啊等啊等着他传数据，就浪费了服务器资源。 &emsp;&emsp;如果是三次握手的话，客户端再给他回一句，我知道了，我等哈就给你发数据，然后这样他两才链接上， &emsp;&emsp;如果客户端没给他回消息，服务器就不会和他建立连接，就不会一直等啊等啊。 &emsp;&emsp; 所以避免浪费服务器资源。 四次挥手：&emsp;&emsp; 链接时是个全双工的过程，一般都是浏览器给服务器说，很少服务器给浏览器说挥手的， 第一次：浏览器给服务器说，我现在要断开tcp链接了啊， 第二次：服务器给浏览器说，知道了，那就断吧，但是这个时候服务器的资源还没有发完，他还会继续给浏览器发消息， 第三次：当他发完了之后，他就跟浏览器说，我现在发完了，咱两可以断开了。（客户端在之前还是接收数据的，只是他不在给服务器发东西了） 第四次：客户端给浏览器说，好的我知道了，那就真正的断开吧。（在第四挥手的时候，有一个等待时间，在这个等待时间里，服务器不再给给客户端发消息的话，过了这段时间，客户端就默认，服务器已经收到 客户端同意和他断开的消息了。 为什么是四次挥手呢？&emsp;&emsp;关闭连接的时候，当接收到FIN通知时，只是说他没啥给你发的了，你不一定没东西给他发啊，你再次给他发FIN时，代表你没东西给他发了，双方都没东西发了，就可以完全关闭了。 &emsp;&emsp;就比如说，我要和你分手了，但是你对我还有感情，当你没感情的时候，也就是咱两都没感情的时候，就可以分手了，不能说我没感情就分手，不公平啊！！ 补充： 四次挥手真实情况: 第一次，浏览器发送FIN 第二次，服务器发送ACK 第三次，服务器发送FIN, 第四次，浏览器发送ACK]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>tcp,网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring bean的生命周期]]></title>
    <url>%2Fjava%2Fspring%2Fspring%20bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[spring bean的生命周期Spring上下文的生命周期 实例化一个Bean，也就是我们通常说的new 按照Spring上下文对实例化的Bean进行配置，也就是IOC注入 如果这个Bean实现了BeanNameAware接口，会调用它实现的setBeanName(String beanId)方法，此处传递的是Spring配置文件中Bean的ID 如果这个Bean实现了BeanFactoryAware接口，会调用它实现的setBeanFactory()，传递的是Spring工厂本身（可以用这个方法获取到其他Bean） 如果这个Bean实现了ApplicationContextAware接口，会调用setApplicationContext(ApplicationContext)方法，传入Spring上下文，该方式同样可以实现步骤4，但比4更好，以为ApplicationContext是BeanFactory的子接口，有更多的实现方法 如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessBeforeInitialization(Object obj, String s)方法，BeanPostProcessor经常被用作是Bean内容的更改，并且由于这个是在Bean初始化结束时调用After方法，也可用于内存或缓存技术 如果这个Bean在Spring配置文件中配置了init-method属性会自动调用其配置的初始化方法 如果这个Bean关联了BeanPostProcessor接口，将会调用postAfterInitialization(Object obj, String s)方法 注意：以上工作完成以后就可以用这个Bean了，那这个Bean是一个single的，所以一般情况下我们调用同一个ID的Bean会是在内容地址相同的实例 当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean接口，会调用其实现的destroy方法 最后，如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的销毁方法 以上10步骤可以作为面试或者笔试的模板，另外我们这里描述的是应用Spring上下文Bean的生命周期，如果应用Spring的工厂也就是BeanFactory的话去掉第5步就Ok了 &emsp;&emsp; Spring框架中，一旦把一个Bean纳入Spring IOC容器之中，这个Bean的生命周期就会交由容器进行管理，一般担当管理角色的是BeanFactory或者ApplicationContext,认识一下Bean的生命周期活动，对更好的利用它有很大的帮助： 下面以BeanFactory为例，说明一个Bean的生命周期活动 Bean的建立， 由BeanFactory读取Bean定义文件，并生成各个实例 Setter注入，执行Bean的属性依赖注入 BeanNameAware的setBeanName(), 如果实现该接口，则执行其setBeanName方法 BeanFactoryAware的setBeanFactory()，如果实现该接口，则执行其setBeanFactory方法 BeanPostProcessor的processBeforeInitialization()，如果有关联的processor，则在Bean初始化之前都会执行这个实例的processBeforeInitialization()方法 InitializingBean的afterPropertiesSet()，如果实现了该接口，则执行其afterPropertiesSet()方法 Bean定义文件中定义init-method BeanPostProcessors的processAfterInitialization()，如果有关联的processor，则在Bean初始化之前都会执行这个实例的processAfterInitialization()方法 DisposableBean的destroy()，在容器关闭时，如果Bean类实现了该接口，则执行它的destroy()方法 Bean定义文件中定义destroy-method，在容器关闭时，可以在Bean定义文件中使用“destory-method”定义的方法 如果使用ApplicationContext来维护一个Bean的生命周期，则基本上与上边的流程相同，只不过在执行BeanNameAware的setBeanName()后，若有Bean类实现了org.springframework.context.ApplicationContextAware接口，则执行其setApplicationContext()方法，然后再进行BeanPostProcessors的processBeforeInitialization() &emsp;&emsp;实际上，ApplicationContext除了向BeanFactory那样维护容器外，还提供了更加丰富的框架功能，如Bean的消息，事件处理机制等]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你连清晨都控制不了，何谈人生？]]></title>
    <url>%2F%E7%94%9F%E6%B4%BB%2F%E4%BD%A0%E8%BF%9E%E6%B8%85%E6%99%A8%E9%83%BD%E6%8E%A7%E5%88%B6%E4%B8%8D%E4%BA%86%EF%BC%8C%E4%BD%95%E8%B0%88%E4%BA%BA%E7%94%9F%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[你连清晨都控制不了，何谈人生？一日之计，始于清晨。南怀瑾先生曾说过：“能控制早晨的人，方可控制人生。”人生的改变，也许就是伴随着清晨的6点钟闹铃开始。 以史为鉴&emsp;&emsp;自古以来，官员便要在清晨上早朝。汉代贾谊在《新书·官人》中写到：“清晨听治，罢朝而议论。”加上古时候车马不便，算上起床、梳洗、换上朝服的时间，官员们至少需要提早半个时辰，即一个小时起床。”五鼓初起，列火满门，将欲趋朝，轩盖如市。”雾色朦胧中，百官上朝。 &emsp;&emsp;古时没有灯，夜里读书不便，文人大多早起看书，学堂开课也早。而现在夜晚灯火通明，夜间活动丰富，不少人选择了晚睡晚起。孰不知，在你沉醉于清晨的美梦时，他人已经走在为梦想拼搏的路上了。最可怕的不是别人比你聪明，而是比你聪明的人，比你还努力。 名人为例&emsp;&emsp;高三学生学习任务重，很多学生为了能多睡十分钟，早饭能免则免。然而，这样的人并不能成为人生赢家，看看那些成功人士的作息，你会发现，提高学习效率，生活质量，从每一个清晨开始。 &emsp;&emsp;伊万卡·特鲁普，川普背后的关键女人，也就是他的女儿。6岁开始买股票赚钱、高中成为模特打工、先到基层锻炼后才回特朗普集团上班，之后还创立了自己的品牌，每天工作16个小时，美国大选期间，要抽出时间给川普站台演讲，下班之后还要回家抱抱孩子，经常一天只睡4小时。在晨曦中醒来，在深夜里睡去。在母亲、地产专家和时尚品牌老板这些角色中自如转换，因她不浪费每一个清晨的时光。 &emsp;&emsp;就算你不看NBA，不知道科比，但你肯定听过一句话：“你见过凌晨4点洛杉矶的天空吗？”科比说：“早上4点正是睡得最舒服、床铺最温暖的时候，但你需要爬起来去训练！你必须有足够的毅力，才能把你从床上拉起来去做这些事。”昨天科比在直播里说到，退役后的他依然早上4点起床。如果之前4点训练是来自成功的紧迫感，那么现在的他更多的是享受。 &emsp;&emsp;杰克·多西 Twitter和Square联合创始人，他每天早晨5点半准时起床，静坐后慢跑6英里。分管两家公司的人，还不能早睡，每一天都要工作满16个小时。因为事情繁多，他把时间规划精确到分钟，把众多的工作内容分配到每一天，并且高度自律严格按照计划进行。 &emsp;&emsp;王健林高居中国富豪前列，仍坚持这每天5点半起床，并且会在7点准时到达办公室，一直工作到晚上七八点钟。为了保持更好的体力与经历，他还坚持每天跑步一小时。 &emsp;&emsp;如今，李嘉诚已80多高龄，但却依然保持早起习惯，无论前一天多晚睡，第二天早晨6点一定会准时起床，随后，打一个半小时高尔夫，保证在8点前到达办公室。 &emsp;&emsp;研究表明，早起者通常起床更快，而且头脑更灵活，能够快速投入注意力要求较高的工作和学习中，也不容易疲劳，精力更旺盛，工作效率更高。加拿大多伦多大学的研究人员发现，任何年龄段的人，早起的情绪更加积极向上，自我感觉更好，健康意识也更加强烈。 &emsp;&emsp;不同行业，不同领域，成功的人都是相似的，他们懂得克制，擅长利用时间，不把有限的时间用在无谓的事上。 时间管理&emsp;&emsp;说到这里，并不是让大家每天一定要起得非常早，充足的睡眠是提高效率的前提，但并不意味着可以无止境地赖在床上。因此，每一个人都应该有行程时间管理观念，合理分配时间。而这种观念最有成效的功能就是提高生活质量和学习效率。 &emsp;&emsp;无论哪个季节，从被窝里挣扎出来都是痛苦的。在前一天准备好第二天要穿的服装，提早半个小时起床，洗漱刷牙，做一个简单的伸展，吃一顿丰富的早餐，心情愉悦，准点打卡学习，你会发现很快便能进入状态，学习效率也有所提高。 &emsp;&emsp;为自己量身打造一个时间表，然后坚持固定时间早起吧。学习忙碌，也别忘了找个时间锻炼身体。一般在一天的学习后，很少人还有精力再去运动健身，不妨把运动的时间放在早上，积极参加学校组织的晨练。要知道，早上的运动可以增加血液循环，迅速唤醒身心。 &emsp;&emsp;一般来说，形成一个良好习惯最低需要21天，那就先给自己定一个短期计划，在21天里选择在固定的时间内早起。如果你连清晨都控制不了，又怎么控制人生。富兰克林曾说：“我未曾见过一个早起勤奋谨慎诚实的人抱怨命运不好。” &emsp;&emsp;每一个不曾起舞的日子，都是对生命的辜负。改变，从清晨开始！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活,成功</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5.LinkedHashSet的实现原理]]></title>
    <url>%2Fjava%2Fjava%20%E9%AB%98%E7%BA%A7%E7%B3%BB%E5%88%97%2F5.LinkedHashSet%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[1. LinkedHashSet概述：&emsp;&emsp; LinkedHashSet是具有可预知迭代顺序的Set接口的哈希表和链接列表实现。此实现与HashSet的不同之处在于，后者维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可为插入顺序或是访问顺序。 注意，此实现不是同步的。如果多个线程同时访问链接的哈希Set，而其中至少一个线程修改了该Set，则它必须保持外部同步。 2. LinkedHashSet的实现：&emsp;&emsp; 对于LinkedHashSet而言，它继承与HashSet、又基于LinkedHashMap来实现的。&emsp;&emsp; LinkedHashSet底层使用LinkedHashMap来保存所有元素，它继承与HashSet，其所有的方法操作上又与HashSet相同，因此LinkedHashSet 的实现上非常简单，只提供了四个构造方法，并通过传递一个标识参数，调用父类的构造器，底层构造一个LinkedHashMap来实现，在相关操作上与父类HashSet的操作相同，直接调用父类HashSet的方法即可。LinkedHashSet的源代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class LinkedHashSet&lt;E&gt; extends HashSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable &#123; private static final long serialVersionUID = -2851667679971038690L; /** * 构造一个带有指定初始容量和加载因子的新空链接哈希set。 * * 底层会调用父类的构造方法，构造一个有指定初始容量和加载因子的LinkedHashMap实例。 * @param initialCapacity 初始容量。 * @param loadFactor 加载因子。 */ public LinkedHashSet(int initialCapacity, float loadFactor) &#123; super(initialCapacity, loadFactor, true); &#125; /** * 构造一个带指定初始容量和默认加载因子0.75的新空链接哈希set。 * * 底层会调用父类的构造方法，构造一个带指定初始容量和默认加载因子0.75的LinkedHashMap实例。 * @param initialCapacity 初始容量。 */ public LinkedHashSet(int initialCapacity) &#123; super(initialCapacity, .75f, true); &#125; /** * 构造一个带默认初始容量16和加载因子0.75的新空链接哈希set。 * * 底层会调用父类的构造方法，构造一个带默认初始容量16和加载因子0.75的LinkedHashMap实例。 */ public LinkedHashSet() &#123; super(16, .75f, true); &#125; /** * 构造一个与指定collection中的元素相同的新链接哈希set。 * * 底层会调用父类的构造方法，构造一个足以包含指定collection * 中所有元素的初始容量和加载因子为0.75的LinkedHashMap实例。 * @param c 其中的元素将存放在此set中的collection。 */ public LinkedHashSet(Collection&lt;? extends E&gt; c) &#123; super(Math.max(2*c.size(), 11), .75f, true); addAll(c); &#125; &#125; &emsp;&emsp; 在父类HashSet中，专为LinkedHashSet提供的构造方法如下，该方法为包访问权限，并未对外公开。123456789101112/** * 以指定的initialCapacity和loadFactor构造一个新的空链接哈希集合。 * 此构造函数为包访问权限，不对外公开，实际只是是对LinkedHashSet的支持。 * * 实际底层会以指定的参数构造一个空LinkedHashMap实例来实现。 * @param initialCapacity 初始容量。 * @param loadFactor 加载因子。 * @param dummy 标记。 */ HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123; map = new LinkedHashMap&lt;E,Object&gt;(initialCapacity, loadFactor); &#125; &emsp;&emsp;由上述源代码可见，LinkedHashSet通过继承HashSet，底层使用LinkedHashMap，以很简单明了的方式来实现了其自身的所有功能。]]></content>
      <categories>
        <category>java高级系列</category>
      </categories>
      <tags>
        <tag>java高级系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.HashSet的实现原理]]></title>
    <url>%2Fjava%2Fjava%20%E9%AB%98%E7%BA%A7%E7%B3%BB%E5%88%97%2F4.HashSet%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[1. HashSet概述：&emsp;&emsp; HashSet实现Set接口，由哈希表（实际上是一个HashMap实例）支持。它不保证set 的迭代顺序；特别是它不保证该顺序恒久不变。此类允许使用null元素。 2. HashSet的实现：&emsp;&emsp; 对于HashSet而言，它是基于HashMap实现的，HashSet底层使用HashMap来保存所有元素，因此HashSet 的实现比较简单，相关HashSet的操作，基本上都是直接调用底层HashMap的相关方法来完成， HashSet的源代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable &#123; static final long serialVersionUID = -5024744406713321676L; // 底层使用HashMap来保存HashSet中所有元素。 private transient HashMap&lt;E,Object&gt; map; // 定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。 private static final Object PRESENT = new Object(); /** * 默认的无参构造器，构造一个空的HashSet。 * * 实际底层会初始化一个空的HashMap，并使用默认初始容量为16和加载因子0.75。 */ public HashSet() &#123; map = new HashMap&lt;E,Object&gt;(); &#125; /** * 构造一个包含指定collection中的元素的新set。 * * 实际底层使用默认的加载因子0.75和足以包含指定 * collection中所有元素的初始容量来创建一个HashMap。 * @param c 其中的元素将存放在此set中的collection。 */ public HashSet(Collection&lt;? extends E&gt; c) &#123; map = new HashMap&lt;E,Object&gt;(Math.max((int) (c.size()/.75f) + 1, 16)); addAll(c); &#125; /** * 以指定的initialCapacity和loadFactor构造一个空的HashSet。 * * 实际底层以相应的参数构造一个空的HashMap。 * @param initialCapacity 初始容量。 * @param loadFactor 加载因子。 */ public HashSet(int initialCapacity, float loadFactor) &#123; map = new HashMap&lt;E,Object&gt;(initialCapacity, loadFactor); &#125; /** * 以指定的initialCapacity构造一个空的HashSet。 * * 实际底层以相应的参数及加载因子loadFactor为0.75构造一个空的HashMap。 * @param initialCapacity 初始容量。 */ public HashSet(int initialCapacity) &#123; map = new HashMap&lt;E,Object&gt;(initialCapacity); &#125; /** * 以指定的initialCapacity和loadFactor构造一个新的空链接哈希集合。 * 此构造函数为包访问权限，不对外公开，实际只是是对LinkedHashSet的支持。 * * 实际底层会以指定的参数构造一个空LinkedHashMap实例来实现。 * @param initialCapacity 初始容量。 * @param loadFactor 加载因子。 * @param dummy 标记。 */ HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123; map = new LinkedHashMap&lt;E,Object&gt;(initialCapacity, loadFactor); &#125; /** * 返回对此set中元素进行迭代的迭代器。返回元素的顺序并不是特定的。 * * 底层实际调用底层HashMap的keySet来返回所有的key。 * 可见HashSet中的元素，只是存放在了底层HashMap的key上， * value使用一个static final的Object对象标识。 * @return 对此set中元素进行迭代的Iterator。 */ public Iterator&lt;E&gt; iterator() &#123; return map.keySet().iterator(); &#125; /** * 返回此set中的元素的数量（set的容量）。 * * 底层实际调用HashMap的size()方法返回Entry的数量，就得到该Set中元素的个数。 * @return 此set中的元素的数量（set的容量）。 */ public int size() &#123; return map.size(); &#125; /** * 如果此set不包含任何元素，则返回true。 * * 底层实际调用HashMap的isEmpty()判断该HashSet是否为空。 * @return 如果此set不包含任何元素，则返回true。 */ public boolean isEmpty() &#123; return map.isEmpty(); &#125; /** * 如果此set包含指定元素，则返回true。 * 更确切地讲，当且仅当此set包含一个满足(o==null ? e==null : o.equals(e)) * 的e元素时，返回true。 * * 底层实际调用HashMap的containsKey判断是否包含指定key。 * @param o 在此set中的存在已得到测试的元素。 * @return 如果此set包含指定元素，则返回true。 */ public boolean contains(Object o) &#123; return map.containsKey(o); &#125; /** * 如果此set中尚未包含指定元素，则添加指定元素。 * 更确切地讲，如果此 set 没有包含满足(e==null ? e2==null : e.equals(e2)) * 的元素e2，则向此set 添加指定的元素e。 * 如果此set已包含该元素，则该调用不更改set并返回false。 * * 底层实际将将该元素作为key放入HashMap。 * 由于HashMap的put()方法添加key-value对时，当新放入HashMap的Entry中key * 与集合中原有Entry的key相同（hashCode()返回值相等，通过equals比较也返回true）， * 新添加的Entry的value会将覆盖原来Entry的value，但key不会有任何改变， * 因此如果向HashSet中添加一个已经存在的元素时，新添加的集合元素将不会被放入HashMap中， * 原来的元素也不会有任何改变，这也就满足了Set中元素不重复的特性。 * @param e 将添加到此set中的元素。 * @return 如果此set尚未包含指定元素，则返回true。 */ public boolean add(E e) &#123; return map.put(e, PRESENT)==null; &#125; /** * 如果指定元素存在于此set中，则将其移除。 * 更确切地讲，如果此set包含一个满足(o==null ? e==null : o.equals(e))的元素e， * 则将其移除。如果此set已包含该元素，则返回true * （或者：如果此set因调用而发生更改，则返回true）。（一旦调用返回，则此set不再包含该元素）。 * * 底层实际调用HashMap的remove方法删除指定Entry。 * @param o 如果存在于此set中则需要将其移除的对象。 * @return 如果set包含指定元素，则返回true。 */ public boolean remove(Object o) &#123; return map.remove(o)==PRESENT; &#125; /** * 从此set中移除所有元素。此调用返回后，该set将为空。 * * 底层实际调用HashMap的clear方法清空Entry中所有元素。 */ public void clear() &#123; map.clear(); &#125; /** * 返回此HashSet实例的浅表副本：并没有复制这些元素本身。 * * 底层实际调用HashMap的clone()方法，获取HashMap的浅表副本，并设置到HashSet中。 */ public Object clone() &#123; try &#123; HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) super.clone(); newSet.map = (HashMap&lt;E, Object&gt;) map.clone(); return newSet; &#125; catch (CloneNotSupportedException e) &#123; throw new InternalError(); &#125; &#125; &#125;]]></content>
      <categories>
        <category>java高级系列</category>
      </categories>
      <tags>
        <tag>java高级系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.LinkedHashMap的实现原理]]></title>
    <url>%2Fjava%2Fjava%20%E9%AB%98%E7%BA%A7%E7%B3%BB%E5%88%97%2F3.LinkedHashMap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[1. LinkedHashMap概述： &emsp; &emsp; LinkedHashMap是Map接口的哈希表和链接列表实现，具有可预知的迭代顺序。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 &emsp; &emsp; LinkedHashMap实现与HashMap的不同之处在于，前者维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。 注意，此实现不是同步的。如果多个线程同时访问链接的哈希映射，而其中至少一个线程从结构上修改了该映射，则它必须保持外部同步。 2. LinkedHashMap的实现： &emsp; &emsp; 对于LinkedHashMap而言，它继承与HashMap、底层使用哈希表与双向链表来保存所有元素。其基本操作与父类HashMap相似，它通过重写父类相关的方法，来实现自己的链接列表特性。下面我们来分析LinkedHashMap的源代码： 1) Entry元素： &emsp; &emsp; LinkedHashMap采用的hash算法和HashMap相同，但是它重新定义了数组中保存的元素Entry，该Entry除了保存当前对象的引用外，还保存了其上一个元素before和下一个元素after的引用，从而在哈希表的基础上又构成了双向链接列表。看源代码：12345678910111213/** * 双向链表的表头元素。 */ private transient Entry&lt;K,V&gt; header; /** * LinkedHashMap的Entry元素。 * 继承HashMap的Entry元素，又保存了其上一个元素before和下一个元素after的引用。 */ private static class Entry&lt;K,V&gt; extends HashMap.Entry&lt;K,V&gt; &#123; Entry&lt;K,V&gt; before, after; …… &#125; 2) 初始化：&emsp; &emsp; 通过源代码可以看出，在LinkedHashMap的构造方法中，实际调用了父类HashMap的相关构造方法来构造一个底层存放的table数组。如：1234public LinkedHashMap(int initialCapacity, float loadFactor) &#123; super(initialCapacity, loadFactor); accessOrder = false; &#125; HashMap中的相关构造方法： 1234567891011121314151617181920public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor); // Find a power of 2 &gt;= initialCapacity int capacity = 1; while (capacity &lt; initialCapacity) capacity &lt;&lt;= 1; this.loadFactor = loadFactor; threshold = (int)(capacity * loadFactor); table = new Entry[capacity]; init(); &#125; &emsp; &emsp; 我们已经知道LinkedHashMap的Entry元素继承HashMap的Entry，提供了双向链表的功能。在上述HashMap的构造器中，最后会调用init()方法，进行相关的初始化，这个方法在HashMap的实现中并无意义，只是提供给子类实现相关的初始化调用。 &emsp; &emsp; LinkedHashMap重写了init()方法，在调用父类的构造方法完成构造后，进一步实现了对其元素Entry的初始化操作。1234void init() &#123; header = new Entry&lt;K,V&gt;(-1, null, null, null); header.before = header.after = header; &#125; 3) 存储： &emsp; &emsp; LinkedHashMap并未重写父类HashMap的put方法，而是重写了父类HashMap的put方法调用的子方法void addEntry(int hash, K key, V value, int bucketIndex) 和void createEntry(int hash, K key, V value, int bucketIndex)，提供了自己特有的双向链接列表的实现。123456789101112131415161718192021222324252627void addEntry(int hash, K key, V value, int bucketIndex) &#123; // 调用create方法，将新元素以双向链表的的形式加入到映射中。 createEntry(hash, key, value, bucketIndex); // 删除最近最少使用元素的策略定义 Entry&lt;K,V&gt; eldest = header.after; if (removeEldestEntry(eldest)) &#123; removeEntryForKey(eldest.key); &#125; else &#123; if (size &gt;= threshold) resize(2 * table.length); &#125; &#125; void createEntry(int hash, K key, V value, int bucketIndex) &#123; HashMap.Entry&lt;K,V&gt; old = table[bucketIndex]; Entry&lt;K,V&gt; e = new Entry&lt;K,V&gt;(hash, key, value, old); table[bucketIndex] = e; // 调用元素的addBrefore方法，将元素加入到哈希、双向链接列表。 e.addBefore(header); size++; &#125; private void addBefore(Entry&lt;K,V&gt; existingEntry) &#123; after = existingEntry; before = existingEntry.before; before.after = this; after.before = this; &#125; 4) 读取： &emsp; &emsp; LinkedHashMap重写了父类HashMap的get方法，实际在调用父类getEntry()方法取得查找的元素后，再判断当排序模式accessOrder为true时，记录访问顺序，将最新访问的元素添加到双向链表的表头，并从原来的位置删除。由于的链表的增加、删除操作是常量级的，故并不会带来性能的损失。12345678910111213141516171819public V get(Object key) &#123; // 调用父类HashMap的getEntry()方法，取得要查找的元素。 Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)getEntry(key); if (e == null) return null; // 记录访问顺序。 e.recordAccess(this); return e.value; &#125; void recordAccess(HashMap&lt;K,V&gt; m) &#123; LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m; // 如果定义了LinkedHashMap的迭代顺序为访问顺序， // 则删除以前位置上的元素，并将最新访问的元素添加到链表表头。 if (lm.accessOrder) &#123; lm.modCount++; remove(); addBefore(lm.header); &#125; &#125; 5) 排序模式：&emsp; &emsp; LinkedHashMap定义了排序模式accessOrder，该属性为boolean型变量，对于访问顺序，为true；对于插入顺序，则为false。 123456private final boolean accessOrder;//一般情况下，不必指定排序模式，其迭代顺序即为默认为插入顺序。看LinkedHashMap的构造方法，如：public LinkedHashMap(int initialCapacity, float loadFactor) &#123; super(initialCapacity, loadFactor); accessOrder = false; &#125; &emsp; &emsp; 这些构造方法都会默认指定排序模式为插入顺序。如果你想构造一个LinkedHashMap，并打算按从近期访问最少到近期访问最多的顺序（即访问顺序）来保存元素，那么请使用下面的构造方法构造LinkedHashMap：123456public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) &#123; super(initialCapacity, loadFactor); this.accessOrder = accessOrder; &#125; &emsp; &emsp; 该哈希映射的迭代顺序就是最后访问其条目的顺序，这种映射很适合构建LRU缓存。LinkedHashMap提供了removeEldestEntry(Map.Entry&lt;K,V&gt; eldest)方法，在将新条目插入到映射后，put和 putAll将调用此方法。该方法可以提供在每次添加新条目时移除最旧条目的实现程序，默认返回false，这样，此映射的行为将类似于正常映射，即永远不能移除最旧的元素。123protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) &#123; return false; &#125; &emsp; &emsp; 此方法通常不以任何方式修改映射，相反允许映射在其返回值的指引下进行自我修改。如果用此映射构建LRU缓存(LRU是Least Recently Used的缩写，即最近最少使用，常用于页面置换算法.)，则非常方便，它允许映射通过删除旧条目来减少内存损耗。 例如：重写此方法，维持此映射只保存100个条目的稳定状态，在每次添加新条目时删除最旧的条目。1234private static final int MAX_ENTRIES = 100; protected boolean removeEldestEntry(Map.Entry eldest) &#123; return size() &gt; MAX_ENTRIES; &#125;]]></content>
      <categories>
        <category>java高级系列</category>
      </categories>
      <tags>
        <tag>java高级系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.HashMap的实现原理]]></title>
    <url>%2Fjava%2Fjava%20%E9%AB%98%E7%BA%A7%E7%B3%BB%E5%88%97%2F2.HashMap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[1.HashMap概述： &emsp; &emsp; HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 2.HashMap的数据结构： &emsp;&emsp; 在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。 从上图中可以看出，HashMap底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个HashMap的时候，就会初始化一个数组。 源码如下：123456789101112/** * The table, resized as necessary. Length MUST Always be a power of two. */ transient Entry[] table; static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; Entry&lt;K,V&gt; next; final int hash; …… &#125; &emsp;&emsp;可以看出，Entry就是数组中的元素，每个 Map.Entry 其实就是一个key-value对，它持有一个指向下一个元素的引用，这就构成了链表。 3.HashMap的存取实现：1) 存储：12345678910111213141516171819202122232425public V put(K key, V value) &#123; // HashMap允许存放null键和null值。 // 当key为null时，调用putForNullKey方法，将value放置在数组第一个位置。 if (key == null) return putForNullKey(value); // 根据key的keyCode重新计算hash值。 int hash = hash(key.hashCode()); // 搜索指定hash值在对应table中的索引。 int i = indexFor(hash, table.length); // 如果 i 索引处的 Entry 不为 null，通过循环不断遍历 e 元素的下一个元素。 for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; // 如果i索引处的Entry为null，表明此处还没有Entry。 modCount++; // 将key、value添加到i索引处。 addEntry(hash, key, value, i); return null; &#125; &emsp;&emsp;从上面的源代码中可以看出：当我们往HashMap中put元素的时候，先根据key的hashCode重新计算hash值，根据hash值得到这个元素在数组中的位置（即下标），如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。 &emsp;&emsp; addEntry(hash, key, value, i)方法根据计算出的hash值，将key-value对放在数组table的i索引处。addEntry 是 HashMap 提供的一个包访问权限的方法，代码如下：12345678910void addEntry(int hash, K key, V value, int bucketIndex) &#123; // 获取指定 bucketIndex 索引处的 Entry Entry&lt;K,V&gt; e = table[bucketIndex]; // 将新创建的 Entry 放入 bucketIndex 索引处，并让新的 Entry 指向原来的 Entry table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e); // 如果 Map 中的 key-value 对的数量超过了极限 if (size++ &gt;= threshold) // 把 table 对象的长度扩充到原来的2倍。 resize(2 * table.length); &#125; &emsp;&emsp; 当系统决定存储HashMap中的key-value对时，完全没有考虑Entry中的value，仅仅只是根据key来计算并决定每个Entry的存储位置。我们完全可以把 Map 集合中的 value 当成 key 的附属，当系统决定了 key 的存储位置之后，value 随之保存在那里即可。 &emsp;&emsp; hash(int h)方法根据key的hashCode重新计算一次散列。此算法加入了高位计算，防止低位不变，高位变化时，造成的hash冲突。1234static int hash(int h) &#123; h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); &#125; &emsp;&emsp; 我们可以看到在HashMap中要找到某个元素，需要根据key的hash值来求得对应数组中的位置。如何计算这个位置就是hash算法。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的 元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表，这样就大大优化了查询的效率。 &emsp;&emsp; 对于任意给定的对象，只要它的 hashCode() 返回值相同，那么程序调用 hash(int h) 方法所计算得到的 hash 码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，“模”运算的消耗还是比较大的，在HashMap中是这样做的：调用 indexFor(int h, int length) 方法来计算该对象应该保存在 table 数组的哪个索引处。indexFor(int h, int length) 方法的代码如下：123static int indexFor(int h, int length) &#123; return h &amp; (length-1); &#125; &emsp;&emsp;这个方法非常巧妙，它通过 h &amp; (table.length -1) 来得到该对象的保存位，而HashMap底层数组的长度总是 2 的 n 次方，这是HashMap在速度上的优化。在 HashMap 构造器中有如下代码：123int capacity = 1; while (capacity &lt; initialCapacity) capacity &lt;&lt;= 1; 这段代码保证初始化时HashMap的容量总是2的n次方，即底层数组的长度总是为2的n次方。当length总是 2 的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。 这看上去很简单，其实比较有玄机的，我们举个例子来说明： 假设数组长度分别为15和16，优化后的hash码分别为8和9，那么&amp;运算后的结果如下：123456h &amp; (table.length-1) hash table.length-18 &amp; (15-1)： 0100 &amp; 1110 =01009 &amp; (15-1)： 0101 &amp; 1110 =0100-----------------------------------------------------------------------------------------------------------------------8 &amp; (16-1)： 0100 &amp; 1111 =01009 &amp; (16-1)： 0101 &amp; 1111 =0101 &emsp;&emsp; 从上面的例子中可以看出：当它们和15-1（1110）“与”的时候，产生了相同的结果，也就是说它们会定位到数组中的同一个位置上去，这就产生了碰撞，8和9会被放到数组中的同一个位置上形成链表，那么查询的时候就需要遍历这个链 表，得到8或者9，这样就降低了查询的效率。同时，我们也可以发现，当数组长度为15的时候，hash值会与15-1（1110）进行“与”，那么 最后一位永远是0，而0001，0011，0101，1001，1011，0111，1101这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！而当数组长度为16时，即为2的n次方时，2n-1得到的二进制数的每个位上的值都为1，这使得在低位上&amp;时，得到的和原hash的低位相同，加之hash(int h)方法对key的hashCode的进一步优化，加入了高位计算，就使得只有相同的hash值的两个值才会被放到数组中的同一个位置上形成链表。 &emsp;&emsp; 所以说，当数组长度为2的n次幂的时候，不同的key算得得index相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。 &emsp;&emsp; 根据上面 put 方法的源代码可以看出，当程序试图将一个key-value对放入HashMap中时，程序首先根据该 key 的 hashCode() 返回值决定该 Entry 的存储位置：如果两个 Entry 的 key 的 hashCode() 返回值相同，那它们的存储位置相同。如果这两个 Entry 的 key 通过 equals 比较返回 true，新添加 Entry 的 value 将覆盖集合中原有 Entry 的 value，但key不会覆盖。如果这两个 Entry 的 key 通过 equals 比较返回 false，新添加的 Entry 将与集合中原有 Entry 形成 Entry 链，而且新添加的 Entry 位于 Entry 链的头部——具体说明继续看 addEntry() 方法的说明。 2) 读取：12345678910111213public V get(Object key) &#123; if (key == null) return getForNullKey(); int hash = hash(key.hashCode()); for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) return e.value; &#125; return null; &#125; &emsp;&emsp; 有了上面存储时的hash算法作为基础，理解起来这段代码就很容易了。从上面的源代码中可以看出：从HashMap中get元素时，首先计算key的hashCode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。 3) 归纳起来简单地说&emsp;&emsp; HashMap 在底层将 key-value 当成一个整体进行处理，这个整体就是一个 Entry 对象。HashMap 底层采用一个 Entry[] 数组来保存所有的 key-value 对，当需要存储一个 Entry 对象时，会根据hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Entry时，也会根据hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Entry。 4.HashMap的resize（rehash）： &emsp;&emsp; 当HashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，因为数组的长度是固定的。所以为了提高查询的效率，就要对HashMap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，这是一个常用的操作，而在HashMap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。 &emsp;&emsp; 那么HashMap什么时候进行扩容呢？当HashMap中的元素个数超过数组大小loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，这是一个折中的取值。也就是说，默认情况下，数组大小为16，那么当HashMap中元素个数超过160.75=12的时候，就把数组的大小扩展为 2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。 5.HashMap的性能参数： HashMap 包含如下几个构造器： HashMap()：构建一个初始容量为 16，负载因子为 0.75 的 HashMap。 HashMap(int initialCapacity)：构建一个初始容量为 initialCapacity，负载因子为 0.75 的 HashMap。 HashMap(int initialCapacity, float loadFactor)：以指定初始容量、指定的负载因子创建一个 HashMap。 HashMap的基础构造器HashMap(int initialCapacity, float loadFactor)带有两个参数，它们是初始容量initialCapacity和加载因子loadFactor。 initialCapacity：HashMap的最大容量，即为底层数组的长度。 loadFactor：负载因子loadFactor定义为：散列表的实际元素数目(n)/ 散列表的容量(m)。负载因子衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之愈小。对于使用链表法的散列表来说，查找一个元素的平均时间是O(1+a)，因此如果负载因子越大，对空间的利用更充分，然而后果是查找效率的降低；如果负载因子太小，那么散列表的数据将过于稀疏，对空间造成严重浪费。&emsp;&emsp; HashMap的实现中，通过threshold字段来判断HashMap的最大容量： 1threshold = (int)(capacity * loadFactor); &emsp;&emsp;结合负载因子的定义公式可知，threshold就是在此loadFactor和capacity对应下允许的最大元素数目，超过这个数目就重新resize，以降低实际的负载因子。默认的的负载因子0.75是对空间和时间效率的一个平衡选择。当容量超出此最大容量时， resize后的HashMap容量是容量的两倍： 12if (size++ &gt;= threshold) resize(2 * table.length); 6.Fail-Fast机制：&emsp;&emsp;我们知道java.util.HashMap不是线程安全的，因此如果在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。 &emsp;&emsp;这一策略在源码中的实现是通过modCount域，modCount顾名思义就是修改次数，对HashMap内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount。12345678HashIterator() &#123; expectedModCount = modCount; if (size &gt; 0) &#123; // advance to first entry Entry[] t = table; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null) ; &#125; &#125; &emsp;&emsp;在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map： 注意到modCount声明为volatile，保证线程之间修改的可见性。 123final Entry&lt;K,V&gt; nextEntry() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); 在HashMap的API中指出：&emsp;&emsp;由所有HashMap类的“collection 视图方法”所返回的迭代器都是快速失败的：在迭代器创建之后，如果从结构上对映射进行修改，除非通过迭代器本身的 remove 方法，其他任何时间任何方式的修改，迭代器都将抛出 ConcurrentModificationException。因此，面对并发的修改，迭代器很快就会完全失败，而不冒在将来不确定的时间发生任意不确定行为的风险。 注意，迭代器的快速失败行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出 ConcurrentModificationException。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测程序错误。]]></content>
      <categories>
        <category>java高级系列</category>
      </categories>
      <tags>
        <tag>java高级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.ArrayList的实现原理]]></title>
    <url>%2Fjava%2Fjava%20%E9%AB%98%E7%BA%A7%E7%B3%BB%E5%88%97%2F1.ArrayList%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[1. ArrayList概述：&emsp;&emsp; ArrayList是List接口的可变数组的实现。实现了所有可选列表操作，并允许包括 null 在内的所有元素。除了实现 List 接口外，此类还提供一些方法来操作内部用来存储列表的数组的大小。 &emsp;&emsp; 每个ArrayList实例都有一个容量，该容量是指用来存储列表元素的数组的大小。它总是至少等于列表的大小。随着向ArrayList中不断添加元素，其容量也自动增长。自动增长会带来数据向新数组的重新拷贝，因此，如果可预知数据量的多少，可在构造ArrayList时指定其容量。在添加大量元素前，应用程序也可以使用ensureCapacity操作来增加ArrayList实例的容量，这可以减少递增式再分配的数量。 注意，此实现不是同步的。如果多个线程同时访问一个ArrayList实例，而其中至少一个线程从结构上修改了列表，那么它必须保持外部同步。 2. ArrayList的实现：&emsp;&emsp; 对于ArrayList而言，它实现List接口、底层使用数组保存所有元素。其操作基本上是对数组的操作。下面我们来分析ArrayList的源代码： 1) 底层使用数组实现：1private transient Object[] elementData; 2) 构造方法： &emsp;&emsp; ArrayList提供了三种方式的构造器，可以构造一个默认初始容量为10的空列表、构造一个指定初始容量的空列表以及构造一个包含指定collection的元素的列表，这些元素按照该collection的迭代器返回它们的顺序排列的。123456789101112131415161718public ArrayList() &#123; this(10); &#125; public ArrayList(int initialCapacity) &#123; super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); this.elementData = new Object[initialCapacity]; &#125; public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); size = elementData.length; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; 3) 存储：&emsp;&emsp; ArrayList提供了set(int index, E element)、add(E e)、add(int index, E element)、addAll(Collection&lt;? extends E&gt; c)、addAll(int index, Collection&lt;? extends E&gt; c)这些添加元素的方法。下面我们一一讲解：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 用指定的元素替代此列表中指定位置上的元素，并返回以前位于该位置上的元素。 public E set(int index, E element) &#123; RangeCheck(index); E oldValue = (E) elementData[index]; elementData[index] = element; return oldValue; &#125; // 将指定的元素添加到此列表的尾部。 public boolean add(E e) &#123; ensureCapacity(size + 1); elementData[size++] = e; return true; &#125; // 将指定的元素插入此列表中的指定位置。 // 如果当前位置有元素，则向右移动当前位于该位置的元素以及所有后续元素（将其索引加1）。 public void add(int index, E element) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+&quot;, Size: &quot;+size); // 如果数组长度不足，将进行扩容。 ensureCapacity(size+1); // Increments modCount!! // 将 elementData中从Index位置开始、长度为size-index的元素， // 拷贝到从下标为index+1位置开始的新的elementData数组中。 // 即将当前位于该位置的元素以及所有后续元素右移一个位置。 System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125; // 按照指定collection的迭代器所返回的元素顺序，将该collection中的所有元素添加到此列表的尾部。 public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacity(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; &#125; // 从指定的位置开始，将指定collection中的所有元素插入到此列表中。 public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException( &quot;Index: &quot; + index + &quot;, Size: &quot; + size); Object[] a = c.toArray(); int numNew = a.length; ensureCapacity(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0; &#125; 4) 读取：123456// 返回此列表中指定位置上的元素。 public E get(int index) &#123; RangeCheck(index); return (E) elementData[index]; &#125; 5) 删除： ArrayList提供了根据下标或者指定对象两种方式的删除功能。如下：123456789101112131415161718192021222324252627282930313233// 移除此列表中指定位置上的元素。 public E remove(int index) &#123; RangeCheck(index); modCount++; E oldValue = (E) elementData[index]; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // Let gc do its work return oldValue; &#125; // 移除此列表中首次出现的指定元素（如果存在）。这是应为ArrayList中允许存放重复的元素。 public boolean remove(Object o) &#123; // 由于ArrayList中允许存放null，因此下面通过两种情况来分别处理。 if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; // 类似remove(int index)，移除列表中指定位置上的元素。 fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; 注意：从数组中移除元素的操作，也会导致被移除的元素以后的所有元素的向左移动一个位置。6) 调整数组容量：&emsp;&emsp; 从上面介绍的向ArrayList中存储元素的代码中，我们看到，每当向数组中添加元素时，都要去检查添加后元素的个数是否会超出当前数组的长度，如果超出，数组将会进行扩容，以满足添加数据的需求。数组扩容通过一个公开的方法ensureCapacity(int minCapacity)来实现。在实际添加大量元素前，我也可以使用ensureCapacity来手动增加ArrayList实例的容量，以减少递增式再分配的数量。123456789101112public void ensureCapacity(int minCapacity) &#123; modCount++; int oldCapacity = elementData.length; if (minCapacity &gt; oldCapacity) &#123; Object oldData[] = elementData; int newCapacity = (oldCapacity * 3)/2 + 1; if (newCapacity &lt; minCapacity) newCapacity = minCapacity; // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); //对于数组里面的元素是复杂Object的时候是浅拷贝 &#125; &#125; &emsp;&emsp;从上述代码中可以看出，数组进行扩容时，会将老数组中的元素重新拷贝一份到新的数组中，每次数组容量的增长大约是其原容量的1.5倍。这种操作的代价是很高的，因此在实际使用时，我们应该尽量避免数组容量的扩张。当我们可预知要保存的元素的多少时，要在构造ArrayList实例时，就指定其容量，以避免数组扩容的发生。或者根据实际需求，通过调用ensureCapacity方法来手动增加ArrayList实例的容量。&emsp;&emsp; ArrayList还给我们提供了将底层数组的容量调整为当前列表保存的实际元素的大小的功能。它可以通过trimToSize方法来实现。代码如下：1234567public void trimToSize() &#123; modCount++; int oldCapacity = elementData.length; if (size &lt; oldCapacity) &#123; elementData = Arrays.copyOf(elementData, size); &#125; &#125; 7) Fail-Fast机制：&emsp;&emsp;ArrayList也采用了快速失败的机制，通过记录modCount参数来实现。在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。 具体介绍请参考我之前的文章深入Java集合学习系列：HashMap的实现原理 中的Fail-Fast机制。]]></content>
      <categories>
        <category>java高级系列</category>
      </categories>
      <tags>
        <tag>java高级系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM内存区域详解（Eden Space、Survivor Space、Old Gen、Code Cache和Perm Gen）]]></title>
    <url>%2Fjava%2Fjvm%2FJVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E8%AF%A6%E8%A7%A3%EF%BC%88Eden%20Space%E3%80%81Survivor%20Space%E3%80%81Old%20Gen%E3%80%81Code%20Cache%E5%92%8CPerm%20Gen%EF%BC%89%2F</url>
    <content type="text"><![CDATA[JVM区域总体分两类，heap区和非heap区。 heap区又分为： Eden Space（伊甸园）、 Survivor Space(幸存者区)、 Old Gen（老年代）。 非heap区又分： Code Cache(代码缓存区)； Perm Gen（永久代）； Jvm Stack(java虚拟机栈)； Local Method Statck(本地方法栈)； 下面我们对每一个内存区域做详细介绍。 堆区(heap区)Eden Space字面意思是伊甸园，对象被创建的时候首先放到这个区域，进行垃圾回收后，不能被回收的对象被放入到空的survivor区域。 Survivor Space幸存者区，用于保存在eden space内存区域中经过垃圾回收后没有被回收的对象。Survivor有两个，分别为To Survivor、 From Survivor，这个两个区域的空间大小是一样的。执行垃圾回收的时候Eden区域不能被回收的对象被放入到空的survivor（也就是To Survivor，同时Eden区域的内存会在垃圾回收的过程中全部释放），另一个survivor（即From Survivor）里不能被回收的对象也会被放入这个survivor（即To Survivor），然后To Survivor 和 From Survivor的标记会互换，始终保证一个survivor是空的。 这里写图片描述Eden Space和Survivor Space都属于新生代，新生代中执行的垃圾回收被称之为Minor GC（因为是对新生代进行垃圾回收，所以又被称为Young GC），每一次Young GC后留下来的对象age加1。 注：GC为Garbage Collection，垃圾回收。 Old Gen老年代，用于存放新生代中经过多次垃圾回收仍然存活的对象，也有可能是新生代分配不了内存的大对象会直接进入老年代。经过多次垃圾回收都没有被回收的对象，这些对象的年代已经足够old了，就会放入到老年代。 当老年代被放满的之后，虚拟机会进行垃圾回收，称之为Major GC。由于Major GC除并发GC外均需对整个堆进行扫描和回收，因此又称为Full GC。 heap区即堆内存，整个堆大小=年轻代大小 + 老年代大小。堆内存默认为物理内存的1/64(&lt;1GB)；默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制，可以通过MinHeapFreeRatio参数进行调整；默认空余堆内存大于70%时，JVM会减少堆直到-Xms的最小限制，可以通过MaxHeapFreeRatio参数进行调整。 非堆内存（非heap区）Code Cache代码缓存区，它主要用于存放JIT所编译的代码。CodeCache代码缓冲区的大小在client模式下默认最大是32m，在server模式下默认是48m，这个值也是可以设置的，它所对应的JVM参数为ReservedCodeCacheSize 和 InitialCodeCacheSize，可以通过如下的方式来为Java程序设置。1-XX:ReservedCodeCacheSize=128m CodeCache缓存区是可能被充满的，当CodeCache满时，后台会收到CodeCache is full的警告信息，如下所示：“CompilerThread0” java.lang.OutOfMemoryError: requested 2854248 bytes for Chunk::new. Out of swap space? 注：JIT编译器是在程序运行期间，将Java字节码编译成平台相关的二进制代码。正因为此编译行为发生在程序运行期间，所以该编译器被称为Just-In-Time编译器。 Perm Gen全称是Permanent Generation space，是指内存的永久保存区域，因而称之为永久代。这个内存区域用于存放Class和Meta的信息，Class在被 Load的时候被放入这个区域。因为Perm里存储的东西永远不会被JVM垃圾回收的，所以如果你的应用程序LOAD很多CLASS的话，就很可能出现PermGen space错误。默认大小为物理内存的1/64。]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员最艰巨的十大任务]]></title>
    <url>%2F%E7%94%9F%E6%B4%BB%2F%E7%A8%8B%E5%BA%8F%E5%91%98%E6%9C%80%E8%89%B0%E5%B7%A8%E7%9A%84%E5%8D%81%E5%A4%A7%E4%BB%BB%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[程序员最艰巨的十大任务 程序员最艰巨的任务跟编写代码没有多少关系。编码是逻辑思路的一种实践，这跟程序员日常工作中的其它任务比起来相对简单。如果你认为自己还是一个水平一般的程序员，在你真正的能进入到高手行列前，请确保你已经克服了下列晋级的障碍。 解释你在干什么 解释软件开发过程是一个很困难的事情。那些非程序员职业的人也许知道很多关于编程的事情，但很显然，他们不会编程。对于他们来说，我们的生活就是在一间黑暗的屋子里趴在键盘前消耗着咖啡。 你会在你的朋友、家人和同事中遇到这样的人，他会认为编码不是一个正确的职业。 形象的说出软件解决方案 根据一些简短的需求——通常是一知半解的，你需要设计出数据结构，软件架构，代码算法，通信协议，以及其它所有针对商业问题的解决方案各种组成部分。然后你需要用一种外行人听的懂的术语将它们表达出来，并需要在规定的时间里提交给客户。 很少有程序员能做好这些。 评估工期 这是程序员痛苦的根源。在开发任务没有完成之前，你是绝对没有可能确定完成这个任务需要的时间。也许程序跟以前写的很相似，但环境变了，问题变了，限制条件变了。 经验会提供一定的判断力，但大部分的程序员都习惯于低估问题难度。这其中的原因是他们只考虑编码方面的因素，而忽略了这个任务清单上的其它事务。 维护他人的代码 针对一个问题可能会有一万种解决方案，一万种写法。接手别人写的代码，意味着你要花无数的时间在成千上万的代码行里探索，理解当初作者的思路。而且，如果是一个不相信注释和文档的程序员留下的半个项目，麻烦就更大了。 软件边界的模糊蔓延和让人吐血的奇怪功能需求 虽 然敏捷开发方法给软件范围的膨胀提供了一定的预备空间，但这并没有起到任何的作用——尤其是当你遇到一些由一时兴起的怪念头产生的功能需求。你知道这样做 必定会失败。你的团队知道这样做必定会失败。但客户觉得很好，而当失败不可避免的出现时，全是你的错，因为是你没有理解他们的真实意图。 在缺少优化和过度优化之间找到平衡点 复杂的软件永远不会做到完美；总会有一些更好的方案。你完全可以没完没了的优化下去，这就是为什么软件项目从来都没有提前完工的。 而另一面，“这样就行了——我以后会优化它的”这种心态也是常见的。代码今天好用，但你知道明天可能会出现麻烦或不能用。当然了，你是不需要去修改它的，它将会留给下一个倒霉蛋程序员。 测试你的代码 单元测试你也写了，软件也提交了测试组，但bug依旧存在… 软件是复杂的，可能包含成千上万行代码。系统中可能存在百万的各种交互和逻辑路径；你不可能完全测试它们。类似的，软件会在不同的条件下跟不同的平台上的不同的软件交互。你不可能所有的都测到。写出好的单元测试是一种枯燥且辛苦的工作。理想情况下，测试应该在着手开发前就已经写好——但你如何向客户解释为什么四个星期过去了仍然没有可用的软件？单元测试并不能覆盖每个问题点。在理想的世界里，应该有一个独立的团队来写测试并积极的去发现问题。不幸的是，对大多数项目来说，这样成本太高，时间不够，于是用开发团队来写测试程序。而开发团队潜意识的会避免很多极端的边界情况。程序员喜欢用符合逻辑的方式处理所有问题。但用户很少是这样的。他们会发现你永远意想不到的问题。 写软件文档 给代码写文档是一项费力耗时的工作。很少有程序员擅长这个、喜欢这个的，并且很少有程序员会花时间去读它们。 处理IT问题 你每天都在研究技术。你也许是一个HTML或PHP程序员，但你很可能会遇到一些例如硬盘损坏、驱动冲突或软件崩溃的问题。解决这些事情不是你的主要责任，但是，除非你解决了这些问题，否者你将无法继续你的开发工作。 不幸的是，对于IT圈外的人来说，程序员应该是软硬件都精通的人。当他们遇到了问题，他们自己不花时间就解决，直接会找你。不论是遇到什么问题：你是用计算机的，你一定知道如何将预算表导入Sage，如何配置Oracle，或为何在他们的黑莓手机上发不出邮件。 当然了，这些打搅绝对不能成为你完不成工作的理由，也没有报酬，不是吗？ 处理人的问题 上面的这些难题都可以总结为“人的问题”。很少有外行人会去建议一个飞行员如何开飞机或建议一个电器工程师如何布线。但很多人却会兴致勃勃的勇敢的建议如何开发软件。 我相信对于这些人没有什么好办法。你需要接受这样的事实：这世界上有一半的智力是低于平均水平的！ [英文原文：The Ten Toughest Tasks in Development ]]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String的split小记]]></title>
    <url>%2Fjava%2Fsplit%E5%B0%8F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[1234567public class SplitDemo &#123; public static void main(String[] args) &#123; String a = &quot;abcooob&quot;; String[] as = a.split(&quot;o&quot;); System.out.println(as.length); &#125;&#125; 运行结果是 4abc b 因为分割成{“abc”,””,””,”b”}的值，这个正常理解。 12345678910public class SplitDemo &#123; public static void main(String[] args) &#123; String a = &quot;abcooo&quot;; String[] as = a.split(&quot;o&quot;); System.out.println(as.length); for (String string : as) &#123; System.out.print(string+&quot;\t&quot;); &#125; &#125;&#125; 这个运行结果是： 1 abc为什么呢？ 看api splitpublic String[] split(String regex)根据给定正则表达式的匹配拆分此字符串。 该方法的作用就像是使用给定的表达式和限制参数 0 来调用两参数 split 方法。因此，所得数组中不包括结尾空字符串。 例如，字符串 “boo:and:foo” 使用这些表达式可生成以下结果： Regex 结果: { “boo”, “and”, “foo” }o { “b”, “”, “:and:f” } 参数： regex - 定界正则表达式 返回： 字符串数组，它是根据给定正则表达式的匹配拆分此字符串确定的 抛出： PatternSyntaxException - 如果正则表达式的语法无效 结论：split分割所得数组中不包括结尾空字符串。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[强引用、软引用、弱引用、虚引用]]></title>
    <url>%2Fjava%2Fjvm%2F%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Java四种引用包括强引用，软引用，弱引用，虚引用。 强引用：只要引用存在，垃圾回收器永远不会回收Object obj = new Object();//可直接通过obj取得对应的对象 如obj.equels(new Object());而这样 obj对象对后面new Object的一个强引用，只有当obj这个引用被释放之后，对象才会被释放掉，这也是我们经常所用到的编码形式。 软引用：非必须引用，内存溢出之前进行回收，可以通过以下代码实现Object obj = new Object();SoftReference sf = new SoftReference(obj);obj = null;sf.get();//有时候会返回null这时候sf是对obj的一个软引用，通过sf.get()方法可以取到这个对象，当然，当这个对象被标记为需要回收的对象时，则返回null；软引用主要用户实现类似缓存的功能，在内存足够的情况下直接通过软引用取值，无需从繁忙的真实来源查询数据，提升速度；当内存不足时，自动删除这部分缓存数据，从真正的来源查询这些数据。 弱引用：第二次垃圾回收时回收，可以通过如下代码实现Object obj = new Object();WeakReference wf = new WeakReference(obj);obj = null;wf.get();//有时候会返回nullwf.isEnQueued();//返回是否被垃圾回收器标记为即将回收的垃圾弱引用是在第二次垃圾回收时回收，短时间内通过弱引用取对应的数据，可以取到，当执行过第二次垃圾回收时，将返回null。弱引用主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾，可以通过弱引用的isEnQueued方法返回对象是否被垃圾回收器标记。 虚引用：垃圾回收时回收，无法通过引用取到对象值，可以通过如下代码实现Object obj = new Object();PhantomReference pf = new PhantomReference(obj);obj=null;pf.get();//永远返回nullpf.isEnQueued();//返回是否从内存中已经删除虚引用是每次垃圾回收的时候都会被回收，通过虚引用的get方法永远获取到的数据为null，因此也被成为幽灵引用。虚引用主要用于检测对象是否已经从内存中删除。]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos安装常用工具]]></title>
    <url>%2Flinux%2Fcentos%E5%AE%89%E8%A3%85%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[1、jdk安装去官网找到最新或者想要下载的版本的连接。通过wget获取。推荐用tar方式安装。 解压 tar -xvzf jdk-7u25-linux-x64.tar.gz -C /opt/jvm/ cd /opt/jvm 重命名 mv jdk... jdk7 vi /etc/profile 插入 #java env JAVA_HOME=/home/gcs/user/java/jdk1.7.0_67 PATH=$JAVA_HOME/bin:$PATH CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar export JAVA_HOME export PATH export CLASSPATH 生效 source /etc/profile 检查 java -version javac 2、安装mysql5.71、配置YUM源在MySQL官网中下载YUM源rpm安装包：http://dev.mysql.com/downloads/repo/yum/(可以去官网找最新的)下载mysql源安装包shell&gt; wget http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm检查mysql源是否安装成功shell&gt; yum repolist enabled | grep “mysql.-community.“看到上图所示表示安装成功 2、安装MySQLshell&gt; yum install mysql-community-server 3、启动MySQL服务 shell&gt; systemctl start mysqld 查看MySQL的启动状态 shell&gt; systemctl status mysqld mysqld.service - MySQL Server Loaded: loaded (/usr/lib/systemd/system/mysqld.service; disabled; vendor preset: disabled) Active: active (running) since 五 2016-06-2404:37:37 CST; 35min ago Main PID: 2888 (mysqld) CGroup: /system.slice/mysqld.service └─2888 /usr/sbin/mysqld –daemonize –pid-file=/var/run/mysqld/mysqld.pid6月 2404:37:36 localhost.localdomain systemd[1]: Starting MySQL Server…6月 2404:37:37 localhost.localdomain systemd[1]: Started MySQL Server.4、开机启动 shell&gt; systemctl enable mysqldshell&gt; systemctl daemon-reload 5、修改root默认密码mysql安装完成之后，在/var/log/mysqld.log文件中给root生成了一个默认密码。通过下面的方式找到root默认密码，然后登录mysql进行修改： shell&gt; grep &apos;temporary password&apos; /var/log/mysqld.log shell&gt; mysql -uroot-pmysql&gt; ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY&apos;MyNewPass4!&apos;; 或者 mysql&gt; set password for&apos;root&apos;@&apos;localhost&apos;=password(&apos;MyNewPass4!&apos;); 注意：mysql5.7默认安装了密码安全检查插件（validate_password），默认密码检查策略要求密码必须包含：大小写字母、数字和特殊符号，并且长度不能少于8位。否则会提示ERROR 1819 (HY000): Your password does not satisfy the current policy requirements错误，如下图所示： 通过msyql环境变量可以查看密码策略的相关信息： mysql&gt; show variables like&apos;%password%&apos;; validate_password_policy：密码策略，默认为MEDIUM策略 validate_password_dictionary_file：密码策略文件，策略为STRONG才需要 validate_password_length：密码最少长度 validate_password_mixed_case_count：大小写字符长度，至少1个 validate_password_number_count ：数字至少1个 validate_password_special_char_count：特殊字符至少1个 上述参数是默认策略MEDIUM的密码检查规则。共有以下几种密码策略：策略 检查规则0 or LOW Length1 or MEDIUM Length; numeric, lowercase/uppercase, and special characters2 or STRONG Length; numeric, lowercase/uppercase, and special characters; dictionary fileMySQL官网密码策略详细说明：http://dev.mysql.com/doc/refman/5.7/en/validate-password-options-variables.html#sysvar_validate_password_policy 修改密码策略在/etc/my.cnf文件添加validate_password_policy配置，指定密码策略 选择0（LOW），1（MEDIUM），2（STRONG）其中一种，选择2需要提供密码字典文件validate_password_policy=0如果不需要密码策略，添加my.cnf文件中添加如下配置禁用即可：validate_password = off重新启动mysql服务使配置生效： systemctl restart mysqld 6、添加远程登录用户默认只允许root帐户在本地登录，如果要在其它机器上连接mysql，必须修改root允许远程连接，或者添加一个允许远程连接的帐户，为了安全起见，我添加一个新的帐户： mysql&gt; GRANT ALL PRIVILEGES ON*.*TO&apos;yangxin&apos;@&apos;%&apos; IDENTIFIED BY&apos;Yangxin0917!&apos;WITH GRANT OPTION; 7、配置默认编码为utf8修改/etc/my.cnf配置文件，在[mysqld]下添加编码配置，如下所示： [mysqld]character_set_server=utf8init_connect=&apos;SET NAMES utf8&apos; 重新启动mysql服务， systemctl restart mysqld 查看数据库默认编码如下所示： 默认配置文件路径： 配置文件：/etc/my.cnf 日志文件：/var/log//var/log/mysqld.log 服务启动脚本：/usr/lib/systemd/system/mysqld.service socket文件：/var/run/mysqld/mysqld.pid]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis3 中provider的使用]]></title>
    <url>%2Fjava%2Fmybatis%2Fmybatis%20provider%20%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[mybatis3提供了4个**provider注解，分别对应增删改查，分别是:InsertProvider、DeleteProvider、UpdateProvider、SelectProvider;如何使用这些注解呢？ 1.这些注解都有统一的2个入参，一个是type，一个是method。type参数的值是你动态sql的类（A）class文件，method是类（A）中的方法名。当然，这些方法都是动态sql，至于动态sql怎么实现，这就可以发挥你的java基础能力，我是结合了自定义注解和java反射基础知识实现了动态sql。下面结合代码讲解一下实现过程。 2.首先你需要定义一个接口类，这个类提供各种各样的增删改查方法。 下面以@SelectProvider为例，依次描述几种典型的使用场景。 1.使用@SelectProvider@SelectProvider是声明在方法基本上的，这个方法定义在Mapper对应的的interface上。 12345public interface UserMapper &#123; @SelectProvider(type = SqlProvider.class, method = "selectUser") @ResultMap("userMap") public User getUser(long userId);&#125; 上例中是个很简单的Mapper接口，其中定义了一个方法：getUser，这个方法根据提供的用户id来查询用户信息，并返回一个User实体bean。这是一个很简单很常用的查询场景：根据key来查询记录并将结果封装成实体bean。其中：@SelectProvider注解用于生成查询用的sql语句，有别于@Select注解，@SelectProvide指定一个Class及其方法，并且通过调用Class上的这个方法来获得sql语句。在我们这个例子中，获取查询sql的方法是SqlProvider.selectUser。@ResultMap注解用于从查询结果集RecordSet中取数据然后拼装实体bean。 2.定义拼装sql的类@SelectProvide中type参数指定的Class类，必须要能够通过无参的构造函数来初始化。@SelectProvide中method参数指定的方法，必须是public的，返回值必须为String，可以为static。12345public class SqlProvider &#123; public String selectUser(long userId) &#123; return "select * from user where userId=" + userId; &#125;&#125; 上面的就是个简单使用，就可以在mybatis中拼接sql了，有这个之后就可以改造mybatis用实体来查询了，就像hibernate一样了。 附加几个mybatis中不常用但很有意思的OGNL用法。 e.method(args) : 调用对象的方法 e.property： 对象属性值，可以多层嵌套使用， e1[e2] :按索引取值（list，数组和map，map使用的时候注意key一样的存在，不存在会报错的） @class@method(args):调用类的静态方法 @class@field:调用类的静态字段值]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于我]]></title>
    <url>%2Fabout%2F</url>
    <content type="text"><![CDATA[2013年大学本科毕业,一直从事java编程的工作,从懵懵懂懂技术人员到现在认为有点技术的人员(要谦虚). 熟悉Java开发，熟悉集合、多线程、IO、异常等常用JDK库；熟悉JavaEE开发，能熟练使用SSH等常见非EJB框架；了解网络、缓存、存储、队列、消息；经常关注GitHub或者开源开源中国里面的开源项目；有使用Netty做网络通信的项目经验。 熟练运用Spring、Hibernate、MyBatis、Struts2、SpringMVC等主流开源框架，独立集成SSH/SSM框架进行轻量级web应用开发；同时也关注国内开源框架，Nutz，Jfinal，Beetle等 熟练掌握Oracle和MySQL的常用命令和内部表结构关系，善于编写存储过程、函数。 熟练使用Linux及其常用Shell命令，可以进行Shell/Python脚本开发。 熟练掌握HTML/CSS、Javascript等Web页面技术, 熟悉使用Bootstrap、Jquery, Ajax，Json、Xml。 熟练使用SVN版本控制，熟悉使用GIT版本控制。熟悉使用Maven。了解OSGI开发。]]></content>
  </entry>
  <entry>
    <title><![CDATA[读书]]></title>
    <url>%2Freading%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[java基础题1]]></title>
    <url>%2Fjava%2Fjava%E9%9D%A2%E8%AF%95%2Fjava%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%981%2F</url>
    <content type="text"><![CDATA[1.多态是什么,接口有什么用(为什么要使用接口编程)? 多态是编译时和运行时表现的形态不同的,在继承和实现关系中,多态主要表现是编译时是父类的形态,运行时是子类的形态. java中接口的作用: 1.解决java中的多继承的问题.接口也为了实现松耦合的思想. 2.因为jdk动态代理中必须是接口和实现类的方式. 2.session和cookie的区别 1、cookie数据存放在客户的浏览器上，session数据放在服务器上。 2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗 考虑到安全应当使用session。 3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能 考虑到减轻服务器性能方面，应当使用COOKIE。 4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。 5、所以个人建议： 将登陆信息等重要信息存放为SESSION 其他信息如果需要保留，可以放在COOKIE中]]></content>
      <categories>
        <category>java面试</category>
      </categories>
      <tags>
        <tag>java面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java面试题（1）]]></title>
    <url>%2Fjava%2Fjava%E9%9D%A2%E8%AF%95%2Fjava%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一套偏向初级和中级开发人员的面试题,答案可以自己脑补下,或者百度下,后续有空会逐个写下博客. 一、基础篇1.1、Java基础 面向对象的特征：继承、封装和多态 final, finally, finalize 的区别 Exception、Error、运行时异常与一般异常有何异同 请写出5种常见到的runtime exception int 和 Integer 有什么区别，Integer的值缓存范围 包装类，装箱和拆箱 String、StringBuilder、StringBuffer 重载和重写的区别 抽象类和接口有什么区别 说说反射的用途及实现 说说自定义注解的场景及实现 HTTP请求的GET与POST方式的区别 Session与Cookie区别 列出自己常用的JDK包 MVC设计思想 equals与==的区别 hashCode和equals方法的区别与联系 什么是Java序列化和反序列化，如何实现Java序列化？或者请解释Serializable 接口的作用 Object类中常见的方法，为什么wait notify会放在Object里边？ Java的平台无关性如何体现出来的 JDK和JRE的区别 Java 8有哪些新特性1.2、Java常见集合 List 和 Set 区别 Set和hashCode以及equals方法的联系 List 和 Map 区别 Arraylist 与 LinkedList 区别 ArrayList 与 Vector 区别 HashMap 和 Hashtable 的区别 HashSet 和 HashMap 区别 HashMap 和 ConcurrentHashMap 的区别 HashMap 的工作原理及代码实现，什么时候用到红黑树 多线程情况下HashMap死循环的问题 HashMap出现Hash DOS攻击的问题 ConcurrentHashMap 的工作原理及代码实现，如何统计所有的元素个数 手写简单的HashMap 看过那些Java集合类的源码 1.3、进程和线程 线程和进程的概念、并行和并发的概念 创建线程的方式及实现 进程间通信的方式 说说 CountDownLatch、CyclicBarrier 原理和区别 说说 Semaphore 原理 说说 Exchanger 原理 ThreadLocal 原理分析，ThreadLocal为什么会出现OOM，出现的深层次原理 讲讲线程池的实现原理 线程池的几种实现方式 线程的生命周期，状态是如何转移的 可参考：《Java多线程编程核心技术》1.4、锁机制 说说线程安全问题，什么是线程安全，如何保证线程安全 重入锁的概念，重入锁为什么可以防止死锁 产生死锁的四个条件（互斥、请求与保持、不剥夺、循环等待） 如何检查死锁（通过jConsole检查死锁） volatile 实现原理（禁止指令重排、刷新内存） synchronized 实现原理（对象监视器） synchronized 与 lock 的区别 AQS同步队列 CAS无锁的概念、乐观锁和悲观锁 常见的原子操作类 什么是ABA问题，出现ABA问题JDK是如何解决的 乐观锁的业务场景及实现方式 Java 8并法包下常见的并发类 偏向锁、轻量级锁、重量级锁、自旋锁的概念 可参考：《Java多线程编程核心技术》1.5、JVM JVM运行时内存区域划分 内存溢出OOM和堆栈溢出SOE的示例及原因、如何排查与解决 如何判断对象是否可以回收或存活 常见的GC回收算法及其含义 常见的JVM性能监控和故障处理工具类：jps、jstat、jmap、jinfo、jconsole等 JVM如何设置参数 JVM性能调优 类加载器、双亲委派模型、一个类的生命周期、类是如何加载到JVM中的 类加载的过程：加载、验证、准备、解析、初始化 强引用、软引用、弱引用、虚引用 Java内存模型JMM1.6、设计模式 常见的设计模式 设计模式的的六大原则及其含义 常见的单例模式以及各种实现方式的优缺点，哪一种最好，手写常见的单利模式 设计模式在实际场景中的应用 Spring中用到了哪些设计模式 MyBatis中用到了哪些设计模式 你项目中有使用哪些设计模式 说说常用开源框架中设计模式使用分析 动态代理很重要！！！1.7、数据结构 树（二叉查找树、平衡二叉树、红黑树、B树、B+树） 深度有限算法、广度优先算法 克鲁斯卡尔算法、普林母算法、迪克拉斯算法 什么是一致性Hash及其原理、Hash环问题 常见的排序算法和查找算法：快排、折半查找、堆排序等 1.8、网络/IO基础 BIO、NIO、AIO的概念 什么是长连接和短连接 Http1.0和2.0相比有什么区别，可参考《Http 2.0》 Https的基本概念 三次握手和四次挥手、为什么挥手需要四次 从游览器中输入URL到页面加载的发生了什么？可参考《从输入URL到页面加载发生了什么》二、数据存储和消息队列2.1、数据库 MySQL 索引使用的注意事项 DDL、DML、DCL分别指什么 explain命令 left join，right join，inner join 数据库事物ACID（原子性、一致性、隔离性、持久性） 事物的隔离级别（读未提交、读以提交、可重复读、可序列化读） 脏读、幻读、不可重复读 数据库的几大范式 数据库常见的命令 说说分库与分表设计 分库与分表带来的分布式困境与应对之策（如何解决分布式下的分库分表，全局表？） 说说 SQL 优化之道 MySQL遇到的死锁问题、如何排查与解决 存储引擎的 InnoDB与MyISAM区别，优缺点，使用场景 索引类别（B+树索引、全文索引、哈希索引）、索引的原理 什么是自适应哈希索引（AHI） 为什么要用 B+tree作为MySQL索引的数据结构 聚集索引与非聚集索引的区别 遇到过索引失效的情况没，什么时候可能会出现，如何解决 limit 20000 加载很慢怎么解决 如何选择合适的分布式主键方案 选择合适的数据存储方案 常见的几种分布式ID的设计方案 常见的数据库优化方案，在你的项目中数据库如何进行优化的2.2、Redis Redis 有哪些数据类型，可参考《Redis常见的5种不同的数据类型详解》 Redis 内部结构 Redis 使用场景 Redis 持久化机制，可参考《使用快照和AOF将Redis数据持久化到硬盘中》 Redis 集群方案与实现 Redis 为什么是单线程的？ 缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级 使用缓存的合理性问题 Redis常见的回收策略2.3、消息队列 消息队列的使用场景 消息的重发补偿解决思路 消息的幂等性解决思路 消息的堆积解决思路 自己如何实现消息队列 如何保证消息的有序性三、开源框架和容器3.1、SSM/Servlet Servlet的生命周期 转发与重定向的区别 BeanFactory 和 ApplicationContext 有什么区别 Spring Bean 的生命周期 Spring IOC 如何实现 Spring中Bean的作用域，默认的是哪一个 说说 Spring AOP、Spring AOP 实现原理 动态代理（CGLib 与 JDK）、优缺点、性能对比、如何选择 Spring 事务实现方式、事务的传播机制、默认的事务类别 Spring 事务底层原理 Spring事务失效（事务嵌套），JDK动态代理给Spring事务埋下的坑，可参考《JDK动态代理给Spring事务埋下的坑！》 如何自定义注解实现功能 Spring MVC 运行流程 Spring MVC 启动流程 Spring 的单例实现原理 Spring 框架中用到了哪些设计模式 Spring 其他产品（Srping Boot、Spring Cloud、Spring Secuirity、Spring Data、Spring AMQP 等） 有没有用到Spring Boot，Spring Boot的认识、原理 MyBatis的原理 可参考《为什么会有Spring》 可参考《为什么会有Spring AOP》3.2、Netty 为什么选择 Netty 说说业务中，Netty 的使用场景 原生的 NIO 在 JDK 1.7 版本存在 epoll bug 什么是TCP 粘包/拆包 TCP粘包/拆包的解决办法 Netty 线程模型 说说 Netty 的零拷贝 Netty 内部执行流程 Netty 重连实现3.3、Tomcat Tomcat的基础架构（Server、Service、Connector、Container） Tomcat如何加载Servlet的 Pipeline-Valve机制 可参考：《四张图带你了解Tomcat系统架构！》 四、分布式 4.1、Nginx 请解释什么是C10K问题或者知道什么是C10K问题吗？ Nginx简介，可参考《Nginx简介》 正向代理和反向代理. Nginx几种常见的负载均衡策略 Nginx服务器上的Master和Worker进程分别是什么 使用“反向代理服务器”的优点是什么?4.2、分布式其他 谈谈业务中使用分布式的场景 Session 分布式方案 Session 分布式处理 分布式锁的应用场景、分布式锁的产生原因、基本概念 分布是锁的常见解决方案 分布式事务的常见解决方案 集群与负载均衡的算法与实现 说说分库与分表设计，可参考《数据库分库分表策略的具体实现方案》 分库与分表带来的分布式困境与应对之策4.3、Dubbo 什么是Dubbo，可参考《Dubbo入门》 什么是RPC、如何实现RPC、RPC 的实现原理，可参考《基于HTTP的RPC实现》 Dubbo中的SPI是什么概念 Dubbo的基本原理、执行流程五、微服务5.1、微服务 前后端分离是如何做的？ 微服务哪些框架 Spring Could的常见组件有哪些？可参考《Spring Cloud概述》 领域驱动有了解吗？什么是领域驱动模型？充血模型、贫血模型 JWT有了解吗，什么是JWT，可参考《前后端分离利器之JWT》 你怎么理解 RESTful 说说如何设计一个良好的 API 如何理解 RESTful API 的幂等性 如何保证接口的幂等性 说说 CAP 定理、BASE 理论 怎么考虑数据一致性问题 说说最终一致性的实现方案 微服务的优缺点，可参考《微服务批判》 微服务与 SOA 的区别 如何拆分服务、水平分割、垂直分割 如何应对微服务的链式调用异常 如何快速追踪与定位问题 如何保证微服务的安全、认证5.2、安全问题 如何防范常见的Web攻击、如何方式SQL注入 服务端通信安全攻防 HTTPS原理剖析、降级攻击、HTTP与HTTPS的对比5.3、性能优化 性能指标有哪些 如何发现性能瓶颈 性能调优的常见手段 说说你在项目中如何进行性能调优六、其他6.1、设计能力 说说你在项目中使用过的UML图 你如何考虑组件化、服务化、系统拆分 秒杀场景如何设计 可参考：《秒杀系统的技术挑战、应对策略以及架构设计总结一二！》6.2、业务工程 说说你的开发流程、如何进行自动化部署的 你和团队是如何沟通的 你如何进行代码评审 说说你对技术与业务的理解 说说你在项目中遇到感觉最难Bug，是如何解决的 介绍一下工作中的一个你认为最有价值的项目，以及在这个过程中的角色、解决的问题、你觉得你们项目还有哪些不足的地方6.3、软实力 说说你的优缺点、亮点 说说你最近在看什么书、什么博客、在研究什么新技术、再看那些开源项目的源代码 说说你觉得最有意义的技术书籍 工作之余做什么事情、平时是如何学习的，怎样提升自己的能力 说说个人发展方向方面的思考 说说你认为的服务端开发工程师应该具备哪些能力 说说你认为的架构师是什么样的，架构师主要做什么 如何看待加班的问题]]></content>
      <categories>
        <category>java面试</category>
      </categories>
      <tags>
        <tag>java面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java面试题-基础篇]]></title>
    <url>%2Fjava%2Fjava%E9%9D%A2%E8%AF%95%2Fjava%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%9F%BA%E7%A1%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[面向对象的特征：继承、封装和多态 继承：子类继承父类所有非私有的属性和方法，使得子类有父类的一些特性。 封装：把对象属性和操作包围起来，向外提供接口和操作的方法 多态：父类在运行的提现子类的属性和方法。 final, finally, finalize 的区别 Final是属性或者方法的修饰词，表示子类不能修改和重写。 Finally是try catch的最后必须操作的语句 Finalize是gc必然会调用的方法。 Exception、Error有何异同 Exception是异常，表示程序编写有错误，有运行时异常和编译时异常。 Error是错误，表示比较严重的错误，比如虚拟机方面的错误 int 和 Integer 有什么区别，Integer的值缓存范围 Int数字类型，Integer包装类，缓存范围-128-127]]></content>
      <categories>
        <category>java面试</category>
      </categories>
      <tags>
        <tag>java面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String的split小记]]></title>
    <url>%2Fjava%2F%E6%97%A7%E5%8D%9A%E5%AE%A2%E8%BD%AC%E7%A7%BB%2FString%E7%9A%84split%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1234567public class SplitDemo &#123; public static void main(String[] args) &#123; String a = "abcooob"; String[] as = a.split("o"); System.out.println(as.length); &#125;&#125; 运行结果是 4abc b 因为分割成{“abc”,””,””,”b”}的值，这个正常理解。 12345678910public class SplitDemo &#123; public static void main(String[] args) &#123; String a = "abcooo"; String[] as = a.split("o"); System.out.println(as.length); for (String string : as) &#123; System.out.print(string+"\t"); &#125; &#125;&#125; 这个运行结果是： 1 abc为什么呢？ 看api splitpublic String[] split(String regex)根据给定正则表达式的匹配拆分此字符串。 该方法的作用就像是使用给定的表达式和限制参数 0 来调用两参数 split 方法。因此，所得数组中不包括结尾空字符串。 例如，字符串 “boo:and:foo” 使用这些表达式可生成以下结果： Regex 结果: { “boo”, “and”, “foo” }o { “b”, “”, “:and:f” } 参数： regex - 定界正则表达式 返回： 字符串数组，它是根据给定正则表达式的匹配拆分此字符串确定的 抛出： PatternSyntaxException - 如果正则表达式的语法无效 结论：split分割所得数组中不包括结尾空字符串。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译器自动优化导致代码可以先后写的问题]]></title>
    <url>%2Fjava%2F%E6%97%A7%E5%8D%9A%E5%AE%A2%E8%BD%AC%E7%A7%BB%2F%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E5%8A%A8%E4%BC%98%E5%8C%96%E5%AF%BC%E8%87%B4%E4%BB%A3%E7%A0%81%E5%8F%AF%E4%BB%A5%E5%85%88%E5%90%8E%E5%86%99%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1234567891011public class Demo1 &#123; static &#123; test = 1;// System.out.println(test); &#125; static int test; public static void main(String[] args) &#123; System.out.println(&quot;Hello World!&quot;); &#125;&#125; 其实上面的代码，编译器会自动编译为： 1234567891011import java.io.PrintStream; public class Demo1&#123; static int test = 1; public static void main(String[] args) &#123; System.out.println(&quot;Hello World!&quot;); &#125;&#125; 所以导致没有定义的，也可以先赋值。 注意问题：要有static的包围着，static会让编译器自动优化。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十七条成功定律]]></title>
    <url>%2F%E7%94%9F%E6%B4%BB%2F%E5%8D%81%E4%B8%83%E6%9D%A1%E6%88%90%E5%8A%9F%E5%AE%9A%E5%BE%8B%2F</url>
    <content type="text"><![CDATA[十七条成功定律——最有价值、带有规律性的定律 1. 积极的心态（PMA黄金定律）积极的心态包括诚恳、忠诚、正直、乐观、勇敢、奋发、创造、机智、亲切、友善、积极、向善、向上、进取、努力、愉快、自信、自勉和有安全感等。 2. 明确的目标你过去和现在的情况并不重要，你将来想获得什么成就才是最重要的。有目标才会成功，如果你对未来没有理想，就做不出什么大事来。 3. 多走些路做个主动的人。要勇于实践，你的成功也就是因为多走了些路，找到了别人未找到的另外一点东西。抓住机会，掌握机会，做个积极主动的人，并养成及时行动的好习惯。 4. 正确的思考方法成功等于正确的思想方法加信念加行动。要想成为思想方法正确的人，必须具备顽强坚定的性格，挖掘潜力，进行“我行”、“我是优秀的”、“还须再改进”的心理暗示。 5. 高度的自制力自制是一种最艰难的美德，有自制力才能抓住成功的机会。成功的最大敌人是自己，缺乏对自己情绪的控制，会把许多稍纵即逝的机会白白浪费掉。 6. 培养领导才能衡量一个领导人物成就的大小，要看他信念的深度、雄心的高度、理想的广度和他对下属关爱的程度。领导要练习赞美的艺术，对人要公正，管理要合乎人性。每一件事情都要精益求精，每一件事都要研究如何改善，每一件事都要订出更高的标准。 7. 建立自信心一个人能否做成、做好一件事，首先看他是否有一个好的心态，以及是否能认真、持续地坚持下去。信心大、心态好，办法才多。 8.迷人的个性对他人的生活、工作表示深切的关心；与人交往中求同存异，避免冲突；学会倾听别人的观点；学会夸奖别人；有微笑的魅力；别吝啬自己的同情；要学会认错，学会宽容大度。 9. 创新致胜创造力是最珍贵的财富。如果你有这种能力，就能把握事业成功的最佳时机，从而创造伟大的奇迹。 10. 充满热诚唯有热忱的态度，才是成功推销自己的重要因素。热忱的心态，是做任何事情都必需的条件。热忱是一种积极意识和状态，能够鼓励和激励他人采取行动，而且还具有感染和鼓舞他人的力量。 11. 专心致志没有专注，就不能应付生活的挑战。干什么都要求专注，专注就是用心，凡事用心终会成功。 12. 富有合作精神合作就有力量，合作是领导才能的基础，合作加速成功。 13. 正确看待失败失败是正常的，颓废是可耻的。要敢于屡败屡战，要摒弃消极思想，全力以赴，不消极等待，在吸取教训中改善求进，“成功是经过多次错误甚至大错之后才得到的”，用毅力克服阻碍，做自己的对手，战胜自己。 14. 永葆进取心进取心是成功的要素，应学会不为报酬而工作的精神，要有任劳任怨的敬业精神，勤学好问，不耻下问是放之四海而皆准的行为准则。 15. 合理安排时间和金钱记住，浪费时间，就是浪费机会。效率就是生命，要把精力集中在那些回报率大的事情上。每天都有一个处理事情的先后顺序及进度，并身体力行，定期检查，杜绝懒惰和拖拖拉拉。金钱不是万恶之源，贪财才是万恶之源。金钱可以使你自信和充分地表现自我，养成储蓄的习惯，经济独立才有真自由。在金钱交往中，无论是公共关系，还是私人关系，应遵守互惠互利的原则，才能健康的长久发展。成功者要有赚钱的素质。 16. 保持身心健康要有健康的身体，因为健全的心灵和健康的身体，是成功的基本保证。要坚持锻炼身体，要经常地给自己充电，积极的心态要求有良好的能量水平。要能够使你自己健康长寿，成功地运用积极心态，你的身体就会越来越健康。 17. 养成良好的习惯好的习惯可以造就人才，坏的习惯可以毁灭人才。习惯，对人的成功与否都有巨大的影响力。好习惯的报酬是成功，好习惯是开启成功大门的钥匙，要有胸襟开阔的心理习惯、勇于纠正自己缺点的习惯、从容不迫的习惯、喜欢运动的习惯等。 这十七条定律涵盖了人类取得成功的所有主观因素，主要与心态、思维方式和行为习惯有关。按十七条成功定律去做，你定能成为一名成功人士。坚持不懈，直到成功！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活,成功</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[成为编程高手的八大奥秘]]></title>
    <url>%2F%E7%94%9F%E6%B4%BB%2F%E7%BC%96%E7%A8%8B%E7%9A%84%E5%85%AB%E5%A4%A7%E5%A5%A5%E7%A7%98%2F</url>
    <content type="text"><![CDATA[成为编程高手的八大奥秘世界上并没有成为高手的捷径，但一些基本原则是可以遵循的。 1、扎实的基础数据结构、离散数学、编译原理，这些是所有计算机科学的基础，如果不掌握它们，很难写出高水平的程序。程序人人都会写，但当你发现写到一定程度很难再提高的时候，就应该想想是不是要回过头来学学这些最基本的理论。不要一开始就去学OOP，即使你再精通OOP，遇到一些基本算法的时候可能也会束手无策。因此多读一些计算机基础理论方面的书籍是非常有必要的。 2、丰富的想像力不要拘泥于固定的思维方式，遇到问题的时候要多想几种解决问题的方案，试试别人从没想过的方法。丰富的想像力是建立在丰富的知识的基础上，除计算机以外，多涉猎其他的学科，比如天文、物理、数学等等。开阔的思维对程序员来说很重要。 3、最简单的是最好的这也许是所有科学都遵循的一条准则，复杂的质能转换原理在爱因斯坦眼里不过是一个简单得不能再简单的公式：E=mc2。简单的方法更容易被人理解，更容易实现，也更容易维护。遇到问题时要优先考虑最简单的方案，只有简单方案不能满足要求时再考虑复杂的方案。 4、不钻牛角尖当你遇到障碍的时候，不妨暂时远离电脑，看看窗外的风景，听听轻音乐，和朋友聊聊天。当我遇到难题的时候会去玩游戏，当负责游戏的那部分大脑细胞极度亢奋的时候，负责编程的那部分大脑细胞就得到了充分的休息。当重新开始工作的时候，我会发现那些难题现在竟然可以迎刃而解。 5、对答案的渴求人类自然科学的发展史就是一个渴求得到答案的过程，即使只能知道答案的一小部分也值得我们去付出。只要你坚定信念，一定要找到问题的答案，你才会付出精力去探索，即使最后没有得到答案，在过程中你也会学到很多东西? 6、多与别人交流三人行必有我师，也许在一次和别人不经意的谈话中，就可以迸出灵感的火花。多上上网，看看别人对同一问题的看法，会给你很大的启发。 7、良好的编程风格注意养成良好的习惯，代码的缩进编排，变量的命名规则要始终保持一致。大家都知道如何排除代码中错误，却往往忽视了对注释的排错。注释是程序的一个重要组成部分，它可以使你的代码更容易理解，而如果代码已经清楚地表达了你的思想，就不必再加注释了，如果注释和代码不一致，那就更加糟糕。 8、韧性和毅力这也许是“高手”和一般程序员最大的区别。高手们并不是天才，他们是在无数个日日夜夜中磨炼出来的。成功能给我们带来无比的喜悦，但过程却是无比的枯燥乏味。你不妨做个测试，找个10000以内的素数表，把它们全都抄下来，然后再检查三遍，如果能够不间断地完成这一工作，你就可以满足这一条]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活,成功</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生命的空隙]]></title>
    <url>%2F%E7%94%9F%E6%B4%BB%2F%E7%94%9F%E5%91%BD%E7%9A%84%E7%A9%BA%E9%9A%99%2F</url>
    <content type="text"><![CDATA[生命的空隙以前很喜欢很喜欢的一段文字.在qq空间存放很久了,把它放在这里方便我可以时常看看. 很多时候，我们需要给自己的生命留一点空隙，就像两车之间的安全距离-——一点缓冲的余地，可以随时调整自己，进退有据。 生活的空间，须借清理挪减而流出；心灵的空间，则经思考开悟而扩展。打桥牌时，我们手中所握有的这副牌不论好坏，都要把它打得淋漓尽致；人生亦然，重要的不是发生了什么事，而是我们处理它的方法和态度。假如我们转身面向阳光，就不可能陷在阴影里。 当我们拿着鲜花送给别人时，首先闻到花香的是我们自己；当我们抓起泥巴想抛别人时，首先弄脏的也是我们的手。一句温暖的话，就像往别人身上洒香水，自己也会沾上两三滴。因此，要时时心存好意，脚走好路，身行好事。光明使我们看不见许多东西。假如没有黑夜，我们便看不到闪亮的星辰。因此，即使是曾经一度使我们能以承受的痛苦磨难，也不会是完全没有价值的。它可以使我们的意志更坚强，思想、人格更成熟。因此，当困难与挫折到来，应平静地面对、乐观地处理。 不要在人我是非中彼此摩擦。有些话语称起来不重，但稍一不慎，便会重重地压倒别人心上；同时，也要训练自己，不要轻易被别人的话扎伤。 你不能决定生命的长度，但你可以扩展它的宽度；你不能改变天生的容貌，但你可以时时展现微笑；你不能企望控制别人，但你可以好好掌握自己；你不能全然预知明天，但你可以充分利用今天；你不能要求事事顺利，到你可以做到事事尽心。 在生活中，定要让自己豁达些，因为豁达的自己才不止于钻牛角尖，也才能乐观进取。还要开朗些，因为开朗的自己才有可能把快乐带给别人，让生活的气氛显得更加愉快。 心里如要常常保持快乐，就必须不把人与人之间的琐事当成是非；有些人常常在烦恼，别人一句无心的话，他却有意地接受，并堆积在心中。 一个快乐的人，不是因为他拥有的多，而是因为他计较得少。多是负担，是另一种失去；少非不足，是另一种有余；舍弃不一定是失去，而是另一种更宽阔的拥有。 美好的生活应该是时时拥有一颗轻松自在的心，不管外在的世界如何变化，自己都能有一片清静的天地。清静不在热闹繁杂中，更不在一颗索求太多的心中，放下挂碍、开阔心胸，心里自然清静无忧。 喜悦能让心灵保持明亮，并且充塞着一种确实而永恒的宁静。我们的心念意境，如能时常保持清明开朗，则展现于周遭的环境，都是美好而善良的。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活,生命</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快乐箴言]]></title>
    <url>%2F%E7%94%9F%E6%B4%BB%2F%E5%BF%AB%E4%B9%90%E7%AE%B4%E8%A8%80%2F</url>
    <content type="text"><![CDATA[快乐箴言 很久以来，人们都认为快乐是理所当然的事，若想拥有它只能顺其自然，不可强求。如今，我们却逐渐意识到，我们与他人的和睦相处是可以创造快乐的。我们可以通过某种方式，使别人更加喜欢自己。一个方式就是不要自私。不要期望任何事情都符合我们自己的方式，不要奢求拥有太多，包括朋友的注意力。另一个方式是在别人身上寻找优点而不是缺点。你会惊奇地发现，这样会给你带来多么大的成功。 不必为了迎合别人而变得毫无主见。事实上，只有你勇于维护自己的正当权利，才会受到大家的喜爱和尊敬。但是请切记，如果你能用彬彬有礼而又令人愉快的方式来处理，那可就再好不过了。友好而礼貌地对待你身边的朋友、长者、陌生人、甚至是那些看起来卑微言轻者，或是你不感兴趣的人，这是培养良好个性的好方法。 不能期望十全十美，犯错误时，我们必须学会如何避免被沮丧情绪缠身。每个人都会犯错误，只要从中吸取教训，就不应被横加指责。许多年轻人在意识到身上具有自己不喜欢的品质，比如脾气暴躁、自私、懒惰等一些令人不快的品质时，便一蹶不振。这对他们可很不利。请记住，我们每个人都有这样或那样的缺点，都需要努力去克服。 与此同时，我们还需牢记：虽然你可能不比别人差，但是也不一定比别人强多少。通往幸福最可靠的方法是要有一个超越别人的心态，就好像是认定自己比别人优秀的那种感觉，这很重要。 出错时，改正错误是明智之举。可能不喜欢某位老师或同学，遇到这种情况，我们应当尽量弄清楚为什么，同时也好好地检讨一下自己，确保自己没有做过那些招致这位老师或同学反感的事情。如果你坚持保持愉悦和礼貌，情况总有一天会好转。如果情况没有好转，那么你只得尝试使自己面对现实，不要对此过于介怀。对你所不能改变的现实，焦虑永远无济于事。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活,快乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给Centos系统设置静态IP]]></title>
    <url>%2Flinux%2F%E7%BB%99Centos%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81IP%2F</url>
    <content type="text"><![CDATA[如果我们想更改主机地址为静态地址或者更改主机名，需要修改的几个文件包括：/etc/sysconfig/network Centos设置主机名和网络配置/etc/sysconfig/network-scripts/ifcfg-eth0 针对特定的网卡进行设置/etc/resolv.conf 设置DNS/etc/hosts 设置指定的域名解析地址 一般我们只需要修改网卡的Centos配置文件就可以了, 例子如下:1DEVICE=eth0BOOTPROTO=staticTYPE=EthernetNAME=&quot;taovps etho0&quot;BROADCAST=192.168.56.255HWADDR=08:00:27:21:F8:80IPADDR=192.168.1.101IPV6INIT=yesIPV6_AUTOCONF=yesNETMASK=255.255.255.0NETWORK=192.168.1.1ONBOOT=yes Centos设置IP完成后，重启一下网卡就可以了：1service network restart 设置后查看是否已经生效1ifconfig eth0 这样就完成了]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>centos</tag>
      </tags>
  </entry>
</search>
